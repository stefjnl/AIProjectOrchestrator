# TDD Implementation Prompt: US-006 Story Generation Service

## Role & Context
You are implementing **US-006: Story Generation Service** for the AI Project Orchestrator using **Test-Driven Development (TDD)**. This is the third stage of AI orchestration, creating the most complex service composition yet with three-stage dependency validation.

## Current System Analysis Required
**CRITICAL**: Before writing any code, examine the existing codebase to understand established patterns:

1. **Study existing services**: `RequirementsAnalysisService` and `ProjectPlanningService`
2. **Analyze established patterns**: Service orchestration, error handling, dependency validation
3. **Review existing models**: Request/Response patterns, Status enums, domain structure
4. **Understand API conventions**: Controller patterns, endpoint naming, error responses
5. **Examine test structure**: Unit test organization, integration test patterns

## TDD Implementation Requirements

### Phase 1: Write All Tests First (ALL MUST FAIL INITIALLY)
Create comprehensive test coverage before ANY implementation:

#### Unit Tests Required
```csharp
// StoryGenerationServiceTests.cs - Minimum 12 tests
- GenerateStoriesAsync_ValidPlanningId_ReturnsStoryGenerationResponse()
- GenerateStoriesAsync_InvalidPlanningId_ThrowsArgumentException()
- GenerateStoriesAsync_RequirementsNotApproved_ThrowsDependencyValidationException()
- GenerateStoriesAsync_PlanningNotApproved_ThrowsDependencyValidationException()
- GenerateStoriesAsync_AIProviderFails_ThrowsServiceProcessingException()
- GenerateStoriesAsync_ContextTooLarge_LogsWarningAndProceeds()
- GetGenerationStatusAsync_ValidId_ReturnsCorrectStatus()
- GetGenerationStatusAsync_InvalidId_ReturnsNotFound()
- GetGenerationResultsAsync_ValidApprovedId_ReturnsStoryCollection()
- CanGenerateStoriesAsync_ValidApprovedPlan_ReturnsTrue()
- CanGenerateStoriesAsync_UnapprovedDependencies_ReturnsFalse()
- ParseAIResponseToStories_ValidResponse_ReturnsStoryCollection()
```

#### Integration Tests Required
```csharp
// StoriesControllerTests.cs - Minimum 6 tests
- POST_Generate_ValidRequest_ReturnsAccepted()
- POST_Generate_InvalidPlanningId_ReturnsBadRequest()
- GET_Status_ValidId_ReturnsStatus()
- GET_Results_ValidApprovedId_ReturnsStories()
- GET_CanGenerate_ValidPlanningId_ReturnsBoolean()
- POST_Generate_ServiceUnavailable_ReturnsServiceUnavailable()
```

### Phase 2: Create Domain Models
Follow existing patterns from US-004 and US-005:

```csharp
// Domain/Models/Stories/ folder
public class StoryGenerationRequest
{
    public Guid PlanningId { get; set; }
    public string? StoryPreferences { get; set; }
    public string? ComplexityLevels { get; set; }
    public string? AdditionalGuidance { get; set; }
}

public class StoryGenerationResponse
{
    public Guid GenerationId { get; set; }
    public List<UserStory> Stories { get; set; } = new();
    public Guid ReviewId { get; set; }
    public StoryGenerationStatus Status { get; set; }
    public DateTime CreatedAt { get; set; }
    public string? ProcessingNotes { get; set; }
}

public class UserStory
{
    public string Title { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public List<string> AcceptanceCriteria { get; set; } = new();
    public string Priority { get; set; } = string.Empty;
    public string? EstimatedComplexity { get; set; }
}

public enum StoryGenerationStatus
{
    Processing,
    PendingReview, 
    Approved,
    Rejected,
    Failed,
    RequirementsNotApproved,
    PlanningNotApproved
}
```

### Phase 3: Create Service Interface
```csharp
// Domain/Services/IStoryGenerationService.cs
public interface IStoryGenerationService
{
    Task<StoryGenerationResponse> GenerateStoriesAsync(StoryGenerationRequest request, CancellationToken cancellationToken = default);
    Task<StoryGenerationStatus> GetGenerationStatusAsync(Guid generationId, CancellationToken cancellationToken = default);
    Task<List<UserStory>?> GetGenerationResultsAsync(Guid generationId, CancellationToken cancellationToken = default);
    Task<bool> CanGenerateStoriesAsync(Guid planningId, CancellationToken cancellationToken = default);
}
```

### Phase 4: Extend Existing Services
**CRITICAL**: Only add minimal methods needed, don't rewrite existing services:

```csharp
// Add to IRequirementsAnalysisService (Domain layer)
Task<string?> GetAnalysisResultsAsync(Guid analysisId, CancellationToken cancellationToken = default);

// Add to IProjectPlanningService (Domain layer)  
Task<string?> GetPlanningResultsAsync(Guid planningId, CancellationToken cancellationToken = default);
```

### Phase 5: Implement Service Following Established Pattern
Study the exact orchestration pattern from `ProjectPlanningService` and replicate:

```csharp
// Application/Services/StoryGenerationService.cs
public class StoryGenerationService : IStoryGenerationService
{
    // Follow EXACT same constructor pattern as ProjectPlanningService
    // Follow EXACT same orchestration workflow:
    // 1. Validate input
    // 2. Validate dependencies (both requirements AND planning approved)
    // 3. Retrieve context from both services
    // 4. Load instructions
    // 5. Create AI request
    // 6. Call AI provider
    // 7. Parse response to story collection
    // 8. Submit for review
    // 9. Track status
    // 10. Return response
}
```

### Phase 6: Create API Controller
Follow existing controller patterns exactly:

```csharp
// API/Controllers/StoriesController.cs
[ApiController]
[Route("api/stories")]
public class StoriesController : ControllerBase
{
    // Follow same pattern as ProjectPlanningController
    // Same error handling, same response types, same logging
}
```

### Phase 7: Create Instruction File
```markdown
# Instructions/StoryGenerator.md
# Role: User Story Generation Specialist
# Task: Transform approved project plans into implementable user stories
# Constraints: Generate 5-15 stories, include acceptance criteria, prioritize by value
# Output Format: Structured markdown with clear story separation
```

## Critical Implementation Requirements

### Context Management Strategy
```csharp
// Monitor total context size from three sources:
var requirementsContext = await _requirementsService.GetAnalysisResultsAsync(request.RequirementsId);
var planningContext = await _planningService.GetPlanningResultsAsync(request.PlanningId); 
var instructions = await _instructionService.GetInstructionAsync("StoryGenerator");

var totalContextSize = EstimateTokenCount(requirementsContext + planningContext + instructions);
if (totalContextSize > MAX_SAFE_TOKENS)
{
    _logger.LogWarning("Large context size: {TokenCount} tokens", totalContextSize);
    // Implement summarization or truncation strategy
}
```

### AI Response Parsing
```csharp
// Robust parsing of AI response into UserStory collection
// Handle various AI output formats gracefully
// Include validation of required story components
private List<UserStory> ParseAIResponseToStories(string aiResponse)
{
    // Parse structured markdown/JSON response
    // Validate each story has title, description, acceptance criteria
    // Handle parsing failures gracefully
    // Return validated story collection
}
```

### Three-Stage Dependency Validation
```csharp
private async Task ValidateAllDependenciesAsync(Guid planningId, CancellationToken cancellationToken)
{
    // 1. Get planning details to find requirements ID
    // 2. Validate requirements analysis is approved  
    // 3. Validate project planning is approved
    // 4. Throw specific exceptions for each failure type
}
```

## Service Registration
Add to Program.cs DI container following existing pattern:
```csharp
builder.Services.AddScoped<IStoryGenerationService, StoryGenerationService>();
```

## Quality Gates
- All tests must pass (run `dotnet test` frequently)
- Solution must build without warnings (`dotnet build`)
- Follow existing code style and patterns exactly
- Comprehensive error handling with structured logging
- Context size monitoring and logging

## Success Verification
1. All tests pass (especially the initially failing ones)
2. API endpoints respond correctly via Swagger/Postman
3. Integration with existing US-004 and US-005 workflows
4. Proper dependency validation prevents invalid requests
5. Context aggregation works with realistic data sizes

**Remember**: Make the smallest possible changes to existing code. Study the working patterns first, then replicate them exactly for the new service. Test frequently and incrementally.