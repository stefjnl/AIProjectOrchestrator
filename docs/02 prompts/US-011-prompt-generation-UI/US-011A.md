# US-011A Implementation: Core Prompt Generation Functionality

## Project Context
You are implementing US-011A for the AI Project Orchestrator - a .NET 9 Clean Architecture application that automates software development workflows. The backend prompt generation service is complete with all REST endpoints functional. You need to implement the frontend interface for Phase 4 (Prompt Generation) to complete the 4-stage AI orchestration pipeline. This is part 1 of 2.

## Current System State
**Existing Frontend Architecture**:
- **Vanilla JavaScript** (no frameworks) with global objects pattern
- **`window.APIClient`**: Global API client in `frontend/js/api.js`
- **`WorkflowManager`**: Class-based state management in `frontend/js/workflow.js`
- **localStorage persistence**: Project-specific state with `workflow_${projectId}` keys
- **4-stage workflow**: Project creation → Requirements → Planning → Stories → **[Prompt Generation - Missing]**

**Working Stages 1-3**:
- ✅ Requirements Analysis (Claude AI → Human Review → Approval)
- ✅ Project Planning (Claude AI → Human Review → Approval)  
- ✅ User Stories (Claude AI → Human Review → Approval)
- ❌ **Prompt Generation (Phase 4) - Not Implemented**

**Backend Endpoints Available**:
- `POST /api/prompts/generate` - Generate prompt for specific story
- `GET /api/prompts/{promptId}/status` - Check prompt generation status
- `GET /api/prompts/can-generate/{storyGenerationId}/{storyIndex}` - Validate prerequisites
- `GET /api/prompts/{promptId}` - Retrieve generated prompt content

## Implementation Requirements

### 1. Extend API Client (`frontend/js/api.js`)

Add these methods to the existing `window.APIClient` object:

```javascript
// Add to existing window.APIClient object
window.APIClient = {
    // ... existing methods ...
    
    // Phase 4: Prompt Generation API methods
    async generatePrompt(storyGenerationId, storyIndex, preferences = {}) {
        return await this.post('/prompts/generate', {
            storyGenerationId,
            storyIndex, 
            technicalPreferences: preferences
        });
    },

    async getPromptStatus(promptId) {
        return await this.get(`/prompts/${promptId}/status`);
    },

    async canGeneratePrompt(storyGenerationId, storyIndex) {
        return await this.get(`/prompts/can-generate/${storyGenerationId}/${storyIndex}`);
    },

    async getPrompt(promptId) {
        return await this.get(`/prompts/${promptId}`);
    },

    // Helper method to retrieve approved stories
    async getApprovedStories(storyGenerationId) {
        // Note: This endpoint may need to be created or use existing story endpoints
        return await this.get(`/stories/${storyGenerationId}/approved`);
    }
};
```

### 2. Enhance WorkflowManager (`frontend/js/workflow.js`)

Extend the existing `WorkflowManager` class with story-level tracking:

```javascript
class WorkflowManager {
    constructor(projectId) {
        this.projectId = projectId;
        this.storageKey = `workflow_${projectId}`;
        this.state = this.loadState() || {
            // ... existing state properties ...
            
            // Phase 4: Story-level prompt tracking
            storyPrompts: {}, // { storyIndex: { promptId, status, pending, approved } }
            approvedStories: [] // Cache of approved story data
        };
    }
    
    // ... existing methods ...
    
    // Phase 4: Story-level prompt management
    setStoryPromptId(storyIndex, promptId) {
        if (!this.state.storyPrompts[storyIndex]) {
            this.state.storyPrompts[storyIndex] = {};
        }
        this.state.storyPrompts[storyIndex].promptId = promptId;
        this.state.storyPrompts[storyIndex].pending = true;
        this.state.storyPrompts[storyIndex].approved = false;
        this.saveState();
    }
    
    setStoryPromptApproved(storyIndex, approved) {
        if (this.state.storyPrompts[storyIndex]) {
            this.state.storyPrompts[storyIndex].approved = approved;
            this.state.storyPrompts[storyIndex].pending = false;
            this.saveState();
        }
    }
    
    getStoryPromptStatus(storyIndex) {
        const prompt = this.state.storyPrompts[storyIndex];
        if (!prompt) return 'Not Started';
        if (prompt.pending) return 'Pending Review';
        if (prompt.approved) return 'Approved';
        return 'Rejected';
    }
    
    // Check approval status for all story prompts
    async checkStoryPromptApprovals() {
        for (const storyIndex in this.state.storyPrompts) {
            const prompt = this.state.storyPrompts[storyIndex];
            if (prompt.pending && prompt.promptId) {
                try {
                    const review = await window.APIClient.getReview(prompt.promptId);
                    if (review.status === 'Approved') {
                        this.setStoryPromptApproved(storyIndex, true);
                    } else if (review.status === 'Rejected') {
                        this.setStoryPromptApproved(storyIndex, false);
                    }
                } catch (error) {
                    console.log(`No review found for prompt ${prompt.promptId}`);
                }
            }
        }
    }
    
    // Enhanced UI update to include Phase 4
    updateWorkflowUI() {
        // ... existing Stage 1-3 logic ...
        
        // Phase 4: Update story prompt interface
        this.updateStoryPromptUI();
    }
    
    updateStoryPromptUI() {
        const storiesContainer = document.getElementById('storiesContainer');
        if (!storiesContainer) return;
        
        this.state.approvedStories.forEach((story, index) => {
            const promptBtn = document.getElementById(`generatePrompt-${index}`);
            const statusDiv = document.getElementById(`promptStatus-${index}`);
            
            if (promptBtn && statusDiv) {
                const status = this.getStoryPromptStatus(index);
                statusDiv.textContent = status;
                statusDiv.className = `prompt-status ${status.toLowerCase().replace(' ', '-')}`;
                
                // Update button state based on status
                if (status === 'Not Started') {
                    promptBtn.disabled = false;
                    promptBtn.textContent = 'Generate Prompt';
                    promptBtn.onclick = () => generateStoryPrompt(index);
                } else if (status === 'Pending Review') {
                    promptBtn.disabled = true;
                    promptBtn.textContent = 'Generating...';
                } else if (status === 'Approved') {
                    promptBtn.disabled = false;
                    promptBtn.textContent = 'View Prompt';
                    promptBtn.onclick = () => viewPrompt(index);
                } else if (status === 'Rejected') {
                    promptBtn.disabled = false;
                    promptBtn.textContent = 'Retry';
                    promptBtn.onclick = () => generateStoryPrompt(index);
                }
            }
        });
    }
}
```

### 3. Add Phase 4 to Workflow Page (`frontend/projects/workflow.html`)

Add this section after the existing Stage 3 (User Stories):

```html
<!-- Add after existing Stage 3 section -->

<!-- Stage 4: Prompt Generation -->
<div class="workflow-stage" id="promptStage">
    <h3>Prompt Generation</h3>
    <div class="stage-status" id="promptStageStatus">Not Started</div>
    
    <!-- Stories Container for Individual Prompt Generation -->
    <div id="storiesContainer" class="stories-container" style="display: none;">
        <h4>Generate Prompts for Individual Stories</h4>
        <div id="storiesList" class="stories-list">
            <!-- Story cards populated dynamically -->
        </div>
    </div>
</div>

<script>
// Add these functions to the existing script section:

// Enhanced initialization to load approved stories
window.addEventListener('DOMContentLoaded', async function() {
    const urlParams = new URLSearchParams(window.location.search);
    const projectId = urlParams.get('projectId');
    
    workflowManager = new WorkflowManager(projectId);
    workflowManager.loadState();
    await workflowManager.checkApprovedReviews();
    await workflowManager.checkStoryPromptApprovals();
    
    // Load approved stories if available
    if (workflowManager.state.storiesApproved && workflowManager.state.storyGenerationId) {
        await loadApprovedStories();
    }
    
    workflowManager.updateWorkflowUI();
});

async function loadApprovedStories() {
    try {
        // For now, simulate story data - replace with actual API call when available
        const mockStories = [
            {
                title: "User Registration",
                userType: "new user",
                wantStatement: "create an account with email and password",
                soThatStatement: "I can access personalized features"
            },
            {
                title: "User Login",
                userType: "registered user", 
                wantStatement: "log into my account",
                soThatStatement: "I can access my personal dashboard"
            }
            // Add more mock stories or implement actual API call
        ];
        
        workflowManager.state.approvedStories = mockStories;
        workflowManager.saveState();
        displayStoriesForPromptGeneration(mockStories);
    } catch (error) {
        console.error('Error loading approved stories:', error);
    }
}

function displayStoriesForPromptGeneration(stories) {
    const storiesContainer = document.getElementById('storiesContainer');
    const storiesList = document.getElementById('storiesList');
    
    if (!storiesContainer || !storiesList) return;
    
    storiesContainer.style.display = 'block';
    
    storiesList.innerHTML = stories.map((story, index) => `
        <div class="story-card" id="story-${index}">
            <div class="story-header">
                <h5>Story ${index + 1}: ${story.title}</h5>
                <div class="prompt-status" id="promptStatus-${index}">Not Started</div>
            </div>
            <div class="story-content">
                <p><strong>As a</strong> ${story.userType}</p>
                <p><strong>I want</strong> ${story.wantStatement}</p>
                <p><strong>So that</strong> ${story.soThatStatement}</p>
            </div>
            <div class="story-actions">
                <button id="generatePrompt-${index}" 
                        onclick="generateStoryPrompt(${index})"
                        class="generate-prompt-btn">
                    Generate Prompt
                </button>
            </div>
        </div>
    `).join('');
    
    // Update UI states for existing prompts
    workflowManager.updateStoryPromptUI();
}

async function generateStoryPrompt(storyIndex) {
    try {
        const canGenerate = await window.APIClient.canGeneratePrompt(
            workflowManager.state.storyGenerationId, 
            storyIndex
        );
        
        if (!canGenerate) {
            alert('Cannot generate prompt. Stories must be approved first.');
            return;
        }
        
        const preferences = {
            framework: 'ASP.NET Core',
            testingFramework: 'xUnit',
            architecture: 'Clean Architecture'
        };
        
        const response = await window.APIClient.generatePrompt(
            workflowManager.state.storyGenerationId,
            storyIndex, 
            preferences
        );
        
        workflowManager.setStoryPromptId(storyIndex, response.promptId);
        workflowManager.updateStoryPromptUI();
        
        alert(`Prompt generation started for Story ${storyIndex + 1}. Check the review queue.`);
        
        // Optional: Redirect to review queue
        // window.location.href = '../reviews/queue.html';
        
    } catch (error) {
        alert('Error generating prompt: ' + error.message);
        console.error('Prompt generation error:', error);
    }
}

async function viewPrompt(storyIndex) {
    const prompt = workflowManager.state.storyPrompts[storyIndex];
    if (prompt && prompt.promptId) {
        try {
            const promptData = await window.APIClient.getPrompt(prompt.promptId);
            
            // Simple prompt display - open in new window for now
            const promptWindow = window.open('', '_blank');
            promptWindow.document.write(`
                <html>
                    <head><title>Generated Prompt - Story ${storyIndex + 1}</title></head>
                    <body style="font-family: monospace; padding: 20px;">
                        <h2>Generated Coding Prompt</h2>
                        <button onclick="navigator.clipboard.writeText(document.getElementById('promptContent').textContent)">
                            Copy to Clipboard
                        </button>
                        <hr>
                        <pre id="promptContent">${promptData.generatedPrompt}</pre>
                    </body>
                </html>
            `);
        } catch (error) {
            alert('Error loading prompt: ' + error.message);
        }
    }
}
</script>
```

### 4. Add Basic CSS Styling (`frontend/css/styles.css`)

Add these styles to the existing CSS file:

```css
/* Phase 4: Prompt Generation Styles */
.stories-container {
    margin-top: 20px;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 8px;
    background-color: #f9f9f9;
}

.stories-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 20px;
    margin: 20px 0;
}

.story-card {
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 15px;
    background-color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.story-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    border-bottom: 1px solid #eee;
    padding-bottom: 8px;
}

.story-header h5 {
    margin: 0;
    color: #333;
    font-size: 14px;
}

.prompt-status {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
}

.prompt-status.not-started {
    background-color: #f0f0f0;
    color: #666;
}

.prompt-status.pending-review {
    background-color: #fff3cd;
    color: #856404;
}

.prompt-status.approved {
    background-color: #d4edda;
    color: #155724;
}

.prompt-status.rejected {
    background-color: #f8d7da;
    color: #721c24;
}

.story-content {
    margin: 10px 0;
    font-size: 13px;
}

.story-content p {
    margin: 5px 0;
}

.story-actions {
    margin-top: 10px;
}

.generate-prompt-btn {
    background-color: #007bff;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
}

.generate-prompt-btn:hover:not(:disabled) {
    background-color: #0056b3;
}

.generate-prompt-btn:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
}
```

## Implementation Requirements

### Key Functional Requirements
1. **Individual Story Display**: Show approved stories as cards with title and acceptance criteria
2. **Independent Prompt Generation**: Each story has its own "Generate Prompt" button
3. **Status Tracking**: Visual indicators for Not Started/Pending Review/Approved/Rejected states
4. **State Persistence**: Maintain prompt generation state across browser sessions
5. **Integration**: Work seamlessly with existing review queue workflow
6. **Basic Viewing**: Simple interface to view approved prompts

### Technical Constraints
- **Follow Existing Patterns**: Use identical structure to Stages 1-3 implementation
- **No Framework Dependencies**: Pure vanilla JavaScript, no new dependencies
- **localStorage Integration**: Use existing state management patterns
- **Error Handling**: Match existing error handling and user feedback patterns
- **Responsive Design**: Work on desktop and tablet devices

### Testing & Validation
- Test with multiple stories (simulate 5-10 stories for comprehensive testing)
- Verify state persistence across browser refresh
- Validate error handling for network failures and invalid requests
- Ensure integration with existing review queue functionality
- Test button state changes based on prompt status

## Success Criteria
- Users can see approved stories as individual cards
- Each story generates prompts independently with proper status tracking
- Generated prompts appear in the existing review queue
- State persists across browser sessions
- Simple prompt viewing works for approved prompts
- Error handling provides meaningful feedback
- Integration doesn't break existing Stages 1-3 functionality

## Notes
- Start with mock story data for testing, replace with actual API integration
- Keep the implementation simple and consistent with existing patterns
- Focus on core functionality - enhanced UX features will be implemented in US-011B
- Ensure proper error handling and user feedback throughout the workflow

This implementation completes the 4-stage AI orchestration pipeline, transforming the system into a complete prompt engineering platform for AI-assisted development.