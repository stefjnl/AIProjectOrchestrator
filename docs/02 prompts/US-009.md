# US-009: Blazor Server UI Foundation - Implementation Prompt

## Context & Objectives

You are implementing a **Blazor Server UI** for an existing AI Project Orchestrator system that automates software development workflows through AI model orchestration. The system currently has a complete REST API with four-stage pipeline functionality (Requirements → Planning → Stories → Code Generation).

**Primary Goal**: Create a modern web interface that replaces static HTML with a sophisticated Blazor Server application, providing real-time workflow management and comprehensive AI output review capabilities.

**Learning Focus**: This implementation should demonstrate enterprise-grade Blazor Server patterns, SignalR integration, component architecture, and API integration strategies suitable for senior .NET developer interviews.

## Current System Overview

### Existing Infrastructure (DO NOT MODIFY)
```
AIProjectOrchestrator/
├── src/
│   ├── AIProjectOrchestrator.API/              # Complete REST API - USE AS-IS
│   ├── AIProjectOrchestrator.Application/      # Business logic - REFERENCE ONLY
│   ├── AIProjectOrchestrator.Domain/           # Models & interfaces - REFERENCE ONLY
│   └── AIProjectOrchestrator.Infrastructure/   # AI clients & services - REFERENCE ONLY
```

### Working API Endpoints (Available for Integration)
```csharp
// Project Management
GET /api/projects                    # List projects
POST /api/projects                   # Create project
GET /api/projects/{id}               # Get project
PUT /api/projects/{id}               # Update project
DELETE /api/projects/{id}            # Delete project

// AI Orchestration Pipeline
POST /api/requirements/analyze       # Stage 1: Requirements analysis
GET /api/requirements/{id}/status    # Check analysis status

POST /api/planning/create            # Stage 2: Project planning
GET /api/planning/{id}/status        # Check planning status
GET /api/planning/can-create/{id}    # Dependency validation

POST /api/stories/generate           # Stage 3: Story generation
GET /api/stories/{id}/status         # Check story status
GET /api/stories/{id}/results        # Get generated stories
GET /api/stories/can-generate/{id}   # Dependency validation

// Human Review System
POST /api/review/submit              # Submit for review
GET /api/review/{id}                 # Get review details
POST /api/review/{id}/approve        # Approve review
POST /api/review/{id}/reject         # Reject with feedback
GET /api/review/pending              # List pending reviews
GET /api/review/dashboard-data       # Dashboard aggregation

// Health & Testing
GET /health                          # System health check
POST /api/aitest/{provider}          # Test AI providers
```

### Domain Models (Available for Reference)
```csharp
// From AIProjectOrchestrator.Domain
public class Project { /* Id, Name, Description, CreatedDate */ }

public class RequirementsAnalysisRequest { /* ProjectDescription, Context, Constraints */ }
public class RequirementsAnalysisResponse { /* AnalysisId, Status, ReviewId, CreatedDate */ }

public class ProjectPlanningRequest { /* RequirementsAnalysisId, PlanningPreferences, etc. */ }
public class ProjectPlanningResponse { /* PlanningId, Status, ReviewId, CreatedDate */ }

public class StoryGenerationRequest { /* ProjectPlanningId, StoryPreferences, etc. */ }  
public class StoryGenerationResponse { /* GenerationId, Status, ReviewId, StoryCount */ }

public class ReviewSubmission { /* Id, Content, SubmittedDate, Status, Decision */ }
public class ReviewDecision { /* Approved, Feedback, ReviewDate, ReviewerId */ }

// Status enums: Processing, PendingReview, Approved, Rejected, Failed
```

## Implementation Requirements

### 1. Project Structure & Setup
**Create new Blazor Server project** with proper integration:

```
AIProjectOrchestrator.Web/
├── Pages/
│   ├── _ViewImports.cshtml           # Global using statements
│   ├── _ViewStart.cshtml             # Layout configuration
│   ├── Index.razor                   # Dashboard home page
│   ├── Projects/
│   │   ├── ProjectsList.razor        # Project management list
│   │   ├── ProjectDetails.razor      # Individual project workflow
│   │   └── CreateProject.razor       # Project creation form
│   ├── Review/
│   │   ├── ReviewQueue.razor         # Pending reviews management
│   │   └── ReviewWorkspace.razor     # Individual review interface
│   └── Settings/
│       └── AIProviders.razor         # AI provider configuration
├── Components/
│   ├── Layout/
│   │   ├── MainLayout.razor          # Primary layout with sidebar
│   │   ├── NavMenu.razor             # Navigation component
│   │   └── MainLayout.razor.css      # Layout-specific styling
│   ├── Workflow/
│   │   ├── WorkflowProgress.razor    # Four-stage progress indicator
│   │   ├── AIStatusDisplay.razor     # Real-time processing status
│   │   └── StageInterface.razor      # Generic stage input interface
│   ├── Review/
│   │   ├── ReviewCard.razor          # Individual review item display
│   │   ├── ReviewWorkspace.razor     # Enhanced review interface
│   │   └── ApprovalActions.razor     # Approve/reject buttons with feedback
│   └── Common/
│       ├── LoadingSpinner.razor      # Professional loading indicator
│       ├── ErrorDisplay.razor        # User-friendly error presentation
│       └── StatusBadge.razor         # Status indication component
├── Services/
│   ├── APIClient.cs                  # Type-safe API wrapper service
│   └── UIStateService.cs             # Application state management
├── Hubs/
│   └── WorkflowHub.cs                # SignalR hub for real-time updates
├── wwwroot/
│   ├── css/                          # Custom styling
│   ├── js/                           # JavaScript interop if needed
│   └── lib/                          # Static assets
├── Program.cs                        # DI registration, middleware setup
├── appsettings.json                  # UI-specific configuration
└── _Imports.razor                    # Global component imports
```

### 2. API Integration Service
**Create type-safe API client** that wraps existing REST endpoints:

```csharp
public interface IAPIClient
{
    // Project Management
    Task<IEnumerable<Project>> GetProjectsAsync();
    Task<Project> GetProjectAsync(Guid id);
    Task<Project> CreateProjectAsync(Project project);
    Task<Project> UpdateProjectAsync(Guid id, Project project);
    Task DeleteProjectAsync(Guid id);
    
    // AI Orchestration Workflow
    Task<RequirementsAnalysisResponse> AnalyzeRequirementsAsync(RequirementsAnalysisRequest request);
    Task<RequirementsAnalysisStatus> GetRequirementsStatusAsync(Guid analysisId);
    
    Task<ProjectPlanningResponse> CreatePlanAsync(ProjectPlanningRequest request);
    Task<ProjectPlanningStatus> GetPlanningStatusAsync(Guid planningId);
    Task<bool> CanCreatePlanAsync(Guid requirementsAnalysisId);
    
    Task<StoryGenerationResponse> GenerateStoriesAsync(StoryGenerationRequest request);
    Task<StoryGenerationStatus> GetStoryStatusAsync(Guid generationId);
    Task<StoryResults> GetStoryResultsAsync(Guid generationId);
    Task<bool> CanGenerateStoriesAsync(Guid projectPlanningId);
    
    // Review Management
    Task<ReviewSubmission> GetReviewAsync(Guid reviewId);
    Task<bool> ApproveReviewAsync(Guid reviewId, string feedback = null);
    Task<bool> RejectReviewAsync(Guid reviewId, string feedback);
    Task<IEnumerable<ReviewSubmission>> GetPendingReviewsAsync();
    
    // System Health
    Task<HealthCheckResult> GetSystemHealthAsync();
}
```

**Implementation Requirements**:
- Use `IHttpClientFactory` for connection pooling
- Implement retry logic with exponential backoff
- Add comprehensive error handling with user-friendly messages
- Include request/response logging for debugging
- Support cancellation tokens throughout

### 3. SignalR Hub Implementation
**Create WorkflowHub** for real-time status broadcasting:

```csharp
public class WorkflowHub : Hub
{
    // Client method signatures (called from server)
    // await Clients.All.SendAsync("RequirementsAnalysisStarted", analysisId);
    // await Clients.All.SendAsync("RequirementsAnalysisCompleted", analysisId, status);
    // await Clients.All.SendAsync("PlanningStarted", planningId);
    // Similar for all pipeline stages
}
```

**Integration Points**:
- Modify existing Application services to broadcast status updates via IHubContext<WorkflowHub>
- Add client-side JavaScript for automatic UI updates
- Implement connection management with automatic reconnection
- Handle offline scenarios gracefully

### 4. Core Pages Implementation

#### Dashboard (Index.razor)
**Requirements**:
- Project summary cards with workflow status indicators
- Recent activity feed showing latest AI interactions
- Quick action buttons for creating new projects
- System health status with AI provider availability
- Pending review count with direct navigation

#### Project Details Page
**Requirements**:
- Four-stage workflow visualization with current stage highlighting
- Stage-specific input forms (requirements, planning preferences, story options)
- Real-time status updates during AI processing
- Direct navigation to review workspace for pending approvals
- Complete workflow history with timestamps and decisions

#### Review Queue Page
**Requirements**:
- Filterable list of pending reviews across all projects
- Priority indicators based on workflow stage and age
- Bulk operations for efficient review processing
- Direct access to review workspace for each item
- Review history with decision audit trail

### 5. Component Architecture

#### Reusable Components
**WorkflowProgress.razor**: Visual four-stage pipeline with status indicators
**AIStatusDisplay.razor**: Real-time processing status with provider health
**ReviewWorkspace.razor**: Enhanced review interface with side-by-side comparison
**ModelSelector.razor**: AI provider selection with performance metrics
**StatusBadge.razor**: Consistent status display across application

**Design Requirements**:
- Professional styling with consistent color scheme
- Loading states for all async operations
- Error boundaries with graceful degradation
- Accessibility compliance with ARIA labels
- Mobile-responsive design with breakpoint optimization

## Technical Implementation Guidelines

### Development Approach
1. **Start Simple**: Basic navigation and project list/create functionality
2. **Test Early**: Write component tests before complex logic implementation
3. **Integrate Gradually**: Add SignalR after basic pages are functional
4. **Follow Patterns**: Match existing service patterns and conventions
5. **Validate Continuously**: Test each page thoroughly before moving to next

### Clean Architecture Compliance
- **Web Layer Only**: No business logic in Blazor components
- **Service Abstraction**: All API calls through IAPIClient service
- **Model Reuse**: Reference Domain models directly, no UI-specific DTOs
- **Dependency Injection**: Proper service registration with appropriate lifetimes

### Performance Considerations
- **Efficient Rendering**: Minimize component re-renders with proper state management
- **Memory Management**: Proper component disposal with IDisposable pattern
- **Connection Pooling**: Efficient HttpClient usage via IHttpClientFactory
- **Caching Strategy**: Cache frequently accessed data with appropriate invalidation

### Error Handling Strategy
- **User-Friendly Messages**: Convert technical errors to actionable user guidance
- **Graceful Degradation**: UI remains functional when AI services unavailable
- **Retry Mechanisms**: Automatic retry for transient failures with user feedback
- **Comprehensive Logging**: Structured logging with correlation IDs matching API

## Testing Requirements

### Component Testing Strategy
- **Blazor Testing Library**: Use bUnit for component testing
- **Service Mocking**: Mock IAPIClient for isolated component testing
- **State Testing**: Verify component state transitions and lifecycle
- **Event Testing**: Test user interactions and event handling

### Integration Testing
- **Page Navigation**: Full navigation testing across application
- **API Integration**: End-to-end testing with real API calls
- **SignalR Testing**: Real-time communication testing
- **Error Scenarios**: UI handling of various failure conditions

### Manual Testing Scenarios
- **Complete Workflow**: Test full project pipeline from creation to code generation
- **Review Process**: Test comprehensive review workflow with approvals/rejections
- **Real-time Updates**: Verify status updates during AI processing
- **Mobile Experience**: Test responsive design across device sizes

## Configuration & Deployment

### Service Registration (Program.cs)
```csharp
// Add Blazor Server services
builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();

// Add SignalR
builder.Services.AddSignalR();

// Register API client
builder.Services.AddHttpClient<IAPIClient, APIClient>(client => 
{
    client.BaseAddress = new Uri(builder.Configuration.GetConnectionString("APIBaseUrl"));
});

// Register UI services
builder.Services.AddScoped<UIStateService>();

// Configure middleware
app.UseRouting();
app.MapRazorPages();
app.MapBlazorHub();
app.MapHub<WorkflowHub>("/workflowhub");
app.MapFallbackToPage("/_Host");
```

### Configuration Requirements
- **API Integration**: Configure base URL for existing API
- **SignalR Settings**: Connection timeout, reconnection intervals
- **Authentication**: Basic authentication foundation (even if simplified)
- **Logging**: Integrate with existing Serilog configuration

## Success Criteria & Validation

### Functional Requirements
- **Project Management**: Complete CRUD operations through Blazor interface
- **Workflow Navigation**: Seamless progression through four pipeline stages
- **Review Interface**: Professional review workspace with approval/rejection
- **Real-time Updates**: Status changes appear automatically without refresh
- **Error Handling**: Graceful handling of API failures with user feedback

### Technical Excellence
- **Clean Architecture**: Proper separation with no business logic in components
- **Performance**: Page load times under 2 seconds, real-time updates under 500ms
- **Accessibility**: WCAG 2.1 compliance with keyboard navigation and screen readers
- **Responsive Design**: Professional appearance across desktop, tablet, mobile
- **Test Coverage**: Comprehensive component and integration testing

### Learning Value Achievement
- **Advanced Blazor Patterns**: Component lifecycle, state management, JavaScript interop
- **Real-time Applications**: SignalR expertise with connection management and broadcasting
- **Service Integration**: Type-safe API consumption with error handling and retry logic
- **Enterprise UI**: Authentication, logging, performance optimization, accessibility

## Implementation Constraints

### Code Quality Standards
- **Follow Existing Patterns**: Match service registration, error handling, logging patterns from existing codebase
- **Minimal API Changes**: Do not modify existing API endpoints or services
- **Test-Driven Development**: Write component tests before complex implementation
- **Clean Architecture**: Maintain proper layer separation and dependency flow

### Integration Requirements
- **Model Reuse**: Use existing Domain models without creating UI-specific DTOs
- **Configuration Consistency**: Extend existing appsettings.json without breaking changes
- **Error Handling**: Match existing error handling patterns and structured logging
- **Service Patterns**: Follow established DI registration and service lifetime patterns

### Performance & Reliability
- **Memory Management**: Proper component disposal and resource cleanup
- **Connection Resilience**: Robust SignalR connection handling with reconnection
- **Async Operations**: Comprehensive async/await patterns with cancellation support
- **State Synchronization**: Reliable UI state management with backend consistency

## Verification Requirements

### Build & Test Validation
- **Solution Build**: `dotnet build` succeeds without warnings across entire solution
- **Test Suite**: All existing tests continue passing (maintain 101/101 baseline)
- **New Tests**: Blazor component tests implemented and passing
- **Container Integration**: Blazor Server integrates properly with existing Docker setup

### Functional Validation
- **API Integration**: All existing API functionality accessible through Blazor interface
- **Navigation Flow**: Complete workflow navigation without broken links or errors
- **Real-time Features**: SignalR updates working across all supported browsers
- **Mobile Compatibility**: Professional responsive design tested across device sizes

### Learning Objective Validation
- **Component Architecture**: Demonstrate advanced component composition and reuse
- **State Management**: Complex UI state synchronization with proper patterns
- **Performance Awareness**: Understanding of Blazor rendering optimization strategies
- **Enterprise Patterns**: Authentication integration, logging, error handling compliance

## Critical Implementation Notes

### Development Philosophy
1. **Examine Existing Code First**: Study established service patterns before implementation
2. **Incremental Development**: Build basic functionality before adding advanced features
3. **Test Thoroughly**: Comprehensive testing between each implementation phase
4. **Maintain Quality**: All existing functionality must continue working unchanged
5. **Focus on Learning**: Each implementation decision should advance senior developer skills

### Architecture Decisions
- **Hybrid Approach**: Blazor Server consumes existing REST API (validates API design)
- **Component Strategy**: Smart pages with business logic, dumb reusable display components
- **State Management**: Combination of component state and shared services for complex workflows
- **Real-time Integration**: SignalR for status updates with fallback to polling

### Quality Focus Areas
- **Interface Design**: Single responsibility components with clear parameter contracts
- **Service Composition**: Complex API client with proper error handling and retry logic
- **Error Handling**: Graceful degradation with meaningful user feedback
- **Resource Management**: Proper disposal patterns and memory management
- **Security Patterns**: Authentication foundation and secure API communication

This implementation will complete the transformation from a REST API with static HTML to a sophisticated full-stack .NET application with real-time capabilities, providing extensive learning opportunities in modern enterprise web development patterns while maintaining the existing system's architectural integrity.