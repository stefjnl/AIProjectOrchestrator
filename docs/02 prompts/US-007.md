# TDD Implementation Prompt: US-007 Code Generation Service

## Role & Context
You are implementing **US-007: Code Generation Service** for the AI Project Orchestrator using **Test-Driven Development (TDD)**. This is the fourth and final stage of AI orchestration, creating the most complex service with intelligent model routing, file I/O operations, and code quality assessment.

## Current System Analysis Required
**CRITICAL**: Before writing any code, examine the existing codebase to understand established patterns:

1. **Study all existing services**: `RequirementsAnalysisService`, `ProjectPlanningService`, and `StoryGenerationService`
2. **Analyze service orchestration pattern**: Four-stage dependency validation, context aggregation, AI processing workflow
3. **Review model infrastructure**: `IAIClientFactory`, `ClaudeClient`, `LMStudioClient`, `OpenRouterClient` capabilities
4. **Understand file structure**: Domain models, service interfaces, API controllers, test organization
5. **Examine existing tests**: Unit test patterns, integration test structure, mocking strategies

## TDD Implementation Requirements

### Phase 1: Write All Tests First (ALL MUST FAIL INITIALLY)
Create comprehensive test coverage before ANY implementation:

#### Unit Tests Required
```csharp
// CodeGenerationServiceTests.cs - Minimum 15 tests
- GenerateCodeAsync_ValidStoryGenerationId_ReturnsCodeGenerationResponse()
- GenerateCodeAsync_InvalidStoryGenerationId_ThrowsArgumentException()
- GenerateCodeAsync_StoriesNotApproved_ThrowsDependencyValidationException()
- GenerateCodeAsync_AIProviderFails_ThrowsServiceProcessingException()
- GenerateCodeAsync_ContextTooLarge_LogsWarningAndProceeds()
- SelectOptimalModelAsync_ComplexStories_SelectsClaude()
- SelectOptimalModelAsync_CRUDStories_SelectsQwen3Coder()
- SelectOptimalModelAsync_ModelUnavailable_SelectsFallback()
- GenerateCodeAsync_CreatesTestFilesFirst_ReturnsTestAndImplementation()
- ValidateGeneratedCodeAsync_ValidCSharp_ReturnsTrue()
- ValidateGeneratedCodeAsync_InvalidSyntax_ReturnsFalse()
- GetGenerationStatusAsync_ValidId_ReturnsCorrectStatus()
- GetGenerationResultsAsync_ValidApprovedId_ReturnsCodeArtifacts()
- CanGenerateCodeAsync_ValidApprovedStories_ReturnsTrue()
- OrganizeGeneratedFiles_MultipleFiles_CreatesProperStructure()
```

#### Integration Tests Required
```csharp
// CodeControllerTests.cs - Minimum 8 tests
- POST_Generate_ValidRequest_ReturnsAccepted()
- POST_Generate_InvalidStoryGenerationId_ReturnsBadRequest()
- GET_Status_ValidId_ReturnsStatus()
- GET_Results_ValidApprovedId_ReturnsCodeArtifacts()
- GET_Files_ValidId_ReturnsFileList()
- GET_CanGenerate_ValidStoryGenerationId_ReturnsBoolean()
- POST_Generate_ServiceUnavailable_ReturnsServiceUnavailable()
- GET_Results_CreatesZipFile_ReturnsDownloadableContent()
```

### Phase 2: Create Domain Models
Follow existing patterns from US-004, US-005, US-006:

```csharp
// Domain/Models/Code/ folder
public class CodeGenerationRequest
{
    public Guid StoryGenerationId { get; set; }
    public string? TechnicalPreferences { get; set; }
    public string? TargetFramework { get; set; } = ".NET 9";
    public string? CodeStylePreferences { get; set; }
    public string? AdditionalInstructions { get; set; }
}

public class CodeGenerationResponse
{
    public Guid GenerationId { get; set; }
    public List<CodeArtifact> GeneratedFiles { get; set; } = new();
    public List<CodeArtifact> TestFiles { get; set; } = new();
    public string CompilationStatus { get; set; } = string.Empty;
    public Guid ReviewId { get; set; }
    public CodeGenerationStatus Status { get; set; }
    public DateTime CreatedAt { get; set; }
    public string? ProcessingNotes { get; set; }
    public string? SelectedModel { get; set; }
}

public class CodeArtifact
{
    public string FileName { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public string FileType { get; set; } = string.Empty; // "Controller", "Service", "Model", "Test"
    public string RelativePath { get; set; } = string.Empty;
    public bool CompilationValid { get; set; }
    public List<string> ValidationErrors { get; set; } = new();
}

public enum CodeGenerationStatus
{
    Processing,
    SelectingModel,
    GeneratingTests,
    GeneratingCode,
    ValidatingOutput,
    PendingReview,
    Approved,
    Rejected,
    Failed,
    StoriesNotApproved
}
```

### Phase 3: Create Service Interface
```csharp
// Domain/Services/ICodeGenerationService.cs
public interface ICodeGenerationService
{
    Task<CodeGenerationResponse> GenerateCodeAsync(CodeGenerationRequest request, CancellationToken cancellationToken = default);
    Task<CodeGenerationStatus> GetGenerationStatusAsync(Guid generationId, CancellationToken cancellationToken = default);
    Task<List<CodeArtifact>?> GetGenerationResultsAsync(Guid generationId, CancellationToken cancellationToken = default);
    Task<bool> CanGenerateCodeAsync(Guid storyGenerationId, CancellationToken cancellationToken = default);
    Task<List<CodeArtifact>> GetGeneratedFilesAsync(Guid generationId, CancellationToken cancellationToken = default);
    Task<byte[]?> GetGeneratedFilesZipAsync(Guid generationId, CancellationToken cancellationToken = default);
}
```

### Phase 4: Extend Existing Services
**CRITICAL**: Only add minimal methods needed, don't rewrite existing services:

```csharp
// Add to IStoryGenerationService (Domain layer)
Task<List<UserStory>?> GetApprovedStoriesAsync(Guid storyGenerationId, CancellationToken cancellationToken = default);

// Add to IProjectPlanningService (Domain layer)
Task<string?> GetTechnicalContextAsync(Guid planningId, CancellationToken cancellationToken = default);

// Add to IRequirementsAnalysisService (Domain layer) - if needed for additional context
Task<string?> GetBusinessContextAsync(Guid analysisId, CancellationToken cancellationToken = default);
```

### Phase 5: Implement Service Following Established Pattern
Study the exact orchestration pattern from `StoryGenerationService` and extend for four-stage dependency validation:

```csharp
// Application/Services/CodeGenerationService.cs
public class CodeGenerationService : ICodeGenerationService
{
    // Follow EXACT same constructor pattern as previous services
    // Add file system dependencies for code generation
    
    private readonly IStoryGenerationService _storyGenerationService;
    private readonly IProjectPlanningService _projectPlanningService;
    private readonly IRequirementsAnalysisService _requirementsAnalysisService;
    private readonly IInstructionService _instructionService;
    private readonly IAIClientFactory _aiClientFactory;
    private readonly IReviewService _reviewService;
    private readonly ILogger<CodeGenerationService> _logger;
    
    // In-memory storage for status tracking
    private readonly ConcurrentDictionary<Guid, CodeGenerationResponse> _generationResults = new();

    public async Task<CodeGenerationResponse> GenerateCodeAsync(CodeGenerationRequest request, CancellationToken cancellationToken = default)
    {
        // Follow EXACT same orchestration workflow:
        
        // 1. Validate input
        ValidateRequest(request);
        
        // 2. Validate four-stage dependencies (stories approved)
        await ValidateAllDependenciesAsync(request.StoryGenerationId, cancellationToken);
        
        // 3. Retrieve comprehensive context from all upstream services
        var context = await RetrieveComprehensiveContextAsync(request.StoryGenerationId, cancellationToken);
        
        // 4. Analyze stories and select optimal AI model
        var selectedModel = await SelectOptimalModelAsync(context.Stories, context.TechnicalContext, cancellationToken);
        
        // 5. Load model-specific instructions
        var instructions = await _instructionService.GetInstructionAsync($"CodeGenerator_{selectedModel}", cancellationToken);
        
        // 6. Generate tests first (TDD approach)
        var testFiles = await GenerateTestFilesAsync(instructions, context, selectedModel, cancellationToken);
        
        // 7. Generate implementation code
        var codeFiles = await GenerateImplementationAsync(instructions, context, testFiles, selectedModel, cancellationToken);
        
        // 8. Validate generated code quality
        var allFiles = testFiles.Concat(codeFiles).ToList();
        await ValidateGeneratedCodeAsync(allFiles, cancellationToken);
        
        // 9. Organize files by project structure
        var organizedFiles = OrganizeGeneratedFiles(allFiles);
        
        // 10. Submit for review
        var reviewId = await _reviewService.SubmitForReviewAsync(SerializeCodeArtifacts(organizedFiles), cancellationToken);
        
        // 11. Create and track response
        var response = new CodeGenerationResponse
        {
            GenerationId = Guid.NewGuid(),
            GeneratedFiles = organizedFiles.Where(f => f.FileType != "Test").ToList(),
            TestFiles = organizedFiles.Where(f => f.FileType == "Test").ToList(),
            ReviewId = reviewId,
            Status = CodeGenerationStatus.PendingReview,
            CreatedAt = DateTime.UtcNow,
            SelectedModel = selectedModel
        };
        
        _generationResults[response.GenerationId] = response;
        return response;
    }
    
    // Model selection logic
    private async Task<string> SelectOptimalModelAsync(List<UserStory> stories, string technicalContext, CancellationToken cancellationToken)
    {
        // Analyze story complexity and technical requirements
        // Route complex architectural stories to Claude
        // Route standard CRUD operations to Qwen3-coder  
        // Use DeepSeek for alternative implementations
        // Consider model availability via health checks
        
        var complexity = AnalyzeStoryComplexity(stories);
        var availableModels = await GetAvailableModelsAsync(cancellationToken);
        
        if (complexity.HasArchitecturalDecisions && availableModels.Contains("claude"))
            return "claude";
        if (complexity.IsCRUDHeavy && availableModels.Contains("qwen3-coder"))
            return "qwen3-coder";
        if (availableModels.Contains("deepseek"))
            return "deepseek";
            
        // Fallback to first available model
        return availableModels.FirstOrDefault() ?? "claude";
    }
}
```

### Phase 6: Create API Controller
Follow existing controller patterns exactly:

```csharp
// API/Controllers/CodeController.cs
[ApiController]
[Route("api/code")]
public class CodeController : ControllerBase
{
    // Follow same pattern as StoriesController
    // Same error handling, same response types, same logging
    // Add file download capabilities for generated code
    
    [HttpGet("{generationId}/download")]
    public async Task<IActionResult> DownloadGeneratedFiles(Guid generationId, CancellationToken cancellationToken)
    {
        var zipFile = await _codeGenerationService.GetGeneratedFilesZipAsync(generationId, cancellationToken);
        if (zipFile == null)
            return NotFound();
            
        return File(zipFile, "application/zip", $"generated-code-{generationId}.zip");
    }
}
```

### Phase 7: Create Model-Specific Instruction Files
Create separate instruction files for each AI model:

```markdown
# Instructions/CodeGenerator_Claude.md
# Role: Senior Software Architect & Code Generator
# Specialization: Complex architectural decisions, design patterns, integration logic
# Task: Generate production-quality C# code following Clean Architecture principles
# TDD Approach: Generate comprehensive unit tests first, then implementation
# Output Format: Structured code files with proper separation of concerns

# Instructions/CodeGenerator_Qwen3Coder.md  
# Role: Efficient Code Implementation Specialist
# Specialization: CRUD operations, data access layer, service implementations
# Task: Generate clean, efficient C# code with proper error handling
# Focus: Standard business logic, API controllers, service layer implementations

# Instructions/CodeGenerator_DeepSeek.md
# Role: Alternative Implementation Provider  
# Specialization: Code validation and alternative approaches
# Task: Generate alternative implementations for comparison and validation
# Focus: Different approaches to same requirements for quality assurance
```

## Critical Implementation Requirements

### Context Aggregation Strategy
```csharp
private async Task<ComprehensiveContext> RetrieveComprehensiveContextAsync(Guid storyGenerationId, CancellationToken cancellationToken)
{
    // Get user stories
    var stories = await _storyGenerationService.GetApprovedStoriesAsync(storyGenerationId, cancellationToken);
    
    // Get planning context (architectural decisions, technical constraints)
    var planningId = await GetPlanningIdFromStories(storyGenerationId, cancellationToken);
    var technicalContext = await _projectPlanningService.GetTechnicalContextAsync(planningId, cancellationToken);
    
    // Get requirements context (business rules)
    var requirementsId = await GetRequirementsIdFromPlanning(planningId, cancellationToken);
    var businessContext = await _requirementsAnalysisService.GetBusinessContextAsync(requirementsId, cancellationToken);
    
    // Monitor total context size
    var totalContextSize = EstimateTokenCount(stories, technicalContext, businessContext);
    _logger.LogInformation("Comprehensive context size: {TokenCount} tokens", totalContextSize);
    
    return new ComprehensiveContext
    {
        Stories = stories,
        TechnicalContext = technicalContext,
        BusinessContext = businessContext,
        EstimatedTokens = totalContextSize
    };
}
```

### File Organization Strategy
```csharp
private List<CodeArtifact> OrganizeGeneratedFiles(List<CodeArtifact> files)
{
    foreach (var file in files)
    {
        // Organize by Clean Architecture structure
        if (file.FileName.EndsWith("Controller.cs"))
            file.RelativePath = "API/Controllers/";
        else if (file.FileName.EndsWith("Service.cs"))
            file.RelativePath = "Application/Services/";
        else if (file.FileName.EndsWith("Tests.cs"))
            file.RelativePath = "Tests/";
        else if (file.FileName.Contains("Model") || file.FileName.Contains("Request") || file.FileName.Contains("Response"))
            file.RelativePath = "Domain/Models/";
            
        // Set file type for filtering
        file.FileType = DetermineFileType(file.FileName);
    }
    
    return files;
}
```

### Code Quality Validation
```csharp
private async Task<bool> ValidateGeneratedCodeAsync(List<CodeArtifact> artifacts, CancellationToken cancellationToken)
{
    foreach (var artifact in artifacts)
    {
        try
        {
            // Basic C# syntax validation using Roslyn
            var syntaxTree = CSharpSyntaxTree.ParseText(artifact.Content);
            var diagnostics = syntaxTree.GetDiagnostics();
            
            artifact.ValidationErrors = diagnostics
                .Where(d => d.Severity == DiagnosticSeverity.Error)
                .Select(d => d.GetMessage())
                .ToList();
                
            artifact.CompilationValid = !artifact.ValidationErrors.Any();
            
            // Log validation results
            if (!artifact.CompilationValid)
                _logger.LogWarning("Validation failed for {FileName}: {Errors}", 
                    artifact.FileName, string.Join(", ", artifact.ValidationErrors));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error validating {FileName}", artifact.FileName);
            artifact.CompilationValid = false;
            artifact.ValidationErrors.Add($"Validation error: {ex.Message}");
        }
    }
    
    return artifacts.All(a => a.CompilationValid);
}
```

### Zip File Generation
```csharp
public async Task<byte[]?> GetGeneratedFilesZipAsync(Guid generationId, CancellationToken cancellationToken)
{
    if (!_generationResults.TryGetValue(generationId, out var result) || result.Status != CodeGenerationStatus.Approved)
        return null;
        
    using var memoryStream = new MemoryStream();
    using (var archive = new ZipArchive(memoryStream, ZipArchiveMode.Create, true))
    {
        var allFiles = result.GeneratedFiles.Concat(result.TestFiles);
        
        foreach (var file in allFiles)
        {
            var entry = archive.CreateEntry($"{file.RelativePath}{file.FileName}");
            using var entryStream = entry.Open();
            using var writer = new StreamWriter(entryStream);
            await writer.WriteAsync(file.Content);
        }
        
        // Add README with implementation guide
        var readmeEntry = archive.CreateEntry("README.md");
        using var readmeStream = readmeEntry.Open();
        using var readmeWriter = new StreamWriter(readmeStream);
        await readmeWriter.WriteAsync(GenerateImplementationGuide(result));
    }
    
    return memoryStream.ToArray();
}
```

## Service Registration
Add to Program.cs DI container following existing pattern:
```csharp
builder.Services.AddScoped<ICodeGenerationService, CodeGenerationService>();
```

## Quality Gates
- All tests must pass (run `dotnet test` frequently)
- Solution must build without warnings (`dotnet build`)
- Follow existing code style and patterns exactly
- Comprehensive error handling with structured logging
- File I/O operations with proper resource disposal
- Model routing logic with fallback strategies
- Code quality validation with meaningful diagnostics

## Success Verification
1. All tests pass (especially the initially failing ones)
2. API endpoints respond correctly including file download
3. Integration with existing four-stage workflow
4. Model routing selects appropriate AI providers
5. Generated code files are properly organized and downloadable
6. TDD workflow generates tests before implementation
7. Code quality validation identifies syntax issues

**Remember**: This completes the full automation pipeline from ideas to working code. Make the smallest possible changes to existing services. Study the established patterns and extend them for the final orchestration stage. Test thoroughly and incrementally.