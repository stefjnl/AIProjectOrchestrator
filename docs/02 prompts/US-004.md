# Implementation Prompt: US-004 Requirements Analysis Service

## Context & Existing System Analysis

You are implementing **US-004: Requirements Analysis Service** for an AI Project Orchestrator built with Clean Architecture in .NET 9. This creates the first complete end-to-end AI orchestration workflow by integrating three existing production-ready components.

**CRITICAL**: This is an established, working system. You must examine the existing codebase first, understand the established patterns, and make only the minimal necessary changes to add the new functionality. Do not rewrite existing working code.

### Existing Foundation (DO NOT MODIFY)
The system already has these working components:
1. **IInstructionService** - Loads AI instruction files from `/Instructions/` directory
2. **IAIClient & IAIClientFactory** - Multi-provider AI client system with Claude, LM Studio, OpenRouter
3. **IReviewService** - Human review workflow with in-memory storage
4. **Clean Architecture** - Domain, Application, Infrastructure, API layers with proper DI registration

### Integration Objective
Create `RequirementsAnalysisService` that orchestrates these existing services into a complete workflow: Input → AI Processing → Human Review → Output.

## Implementation Requirements

### 1. Domain Layer Additions

Create these new models in `AIProjectOrchestrator.Domain/Models/`:

```csharp
// RequirementsAnalysisRequest.cs
public class RequirementsAnalysisRequest
{
    public string ProjectDescription { get; set; } = string.Empty;
    public string? AdditionalContext { get; set; }
    public string? Constraints { get; set; }
    // Add validation attributes for minimum description length
}

// RequirementsAnalysisResponse.cs  
public class RequirementsAnalysisResponse
{
    public Guid AnalysisId { get; set; }
    public string ProjectDescription { get; set; } = string.Empty;
    public string AnalysisResult { get; set; } = string.Empty;
    public Guid ReviewId { get; set; }
    public RequirementsAnalysisStatus Status { get; set; }
    public DateTime CreatedAt { get; set; }
}

// RequirementsAnalysisStatus.cs
public enum RequirementsAnalysisStatus
{
    Processing,
    PendingReview, 
    Approved,
    Rejected,
    Failed
}
```

Create interface in `AIProjectOrchestrator.Domain/Services/`:

```csharp
// IRequirementsAnalysisService.cs
public interface IRequirementsAnalysisService
{
    Task<RequirementsAnalysisResponse> AnalyzeRequirementsAsync(
        RequirementsAnalysisRequest request,
        CancellationToken cancellationToken = default);
        
    Task<RequirementsAnalysisStatus> GetAnalysisStatusAsync(
        Guid analysisId,
        CancellationToken cancellationToken = default);
}
```

### 2. Application Layer Implementation

Create `RequirementsAnalysisService.cs` in `AIProjectOrchestrator.Application/Services/`:

**Service Orchestration Logic**:
1. Validate input request (minimum description length, required fields)
2. Load "RequirementsAnalyst" instructions using existing `IInstructionService.GetInstructionAsync()`
3. Create `AIRequest` combining instructions + project description
4. Call Claude API using existing `IAIClient` (get Claude client from `IAIClientFactory`)
5. Submit AI response for review using existing `IReviewService.SubmitForReviewAsync()`
6. Return `RequirementsAnalysisResponse` with review ID and pending status

**Dependencies to Inject**:
- `IInstructionService` (existing)
- `IAIClientFactory` (existing) 
- `IReviewService` (existing)
- `ILogger<RequirementsAnalysisService>`

**Error Handling Requirements**:
- Wrap in try-catch with meaningful exception messages
- Handle instruction loading failures with graceful fallback
- Handle AI provider unavailability with proper error response
- Use structured logging with correlation IDs

### 3. API Layer Addition

Create `RequirementsController.cs` in `AIProjectOrchestrator.API/Controllers/`:

**Endpoints Required**:
```csharp
[HttpPost("analyze")]
public async Task<ActionResult<RequirementsAnalysisResponse>> AnalyzeRequirements(
    [FromBody] RequirementsAnalysisRequest request,
    CancellationToken cancellationToken)

[HttpGet("{analysisId:guid}/status")]  
public async Task<ActionResult<RequirementsAnalysisStatus>> GetAnalysisStatus(
    Guid analysisId,
    CancellationToken cancellationToken)
```

Follow the existing controller patterns in the codebase for:
- Constructor DI injection
- Action method structure
- Error handling and HTTP status codes
- Correlation ID usage

### 4. Service Registration

Add to existing DI registration in `Program.cs`:
```csharp
builder.Services.AddScoped<IRequirementsAnalysisService, RequirementsAnalysisService>();
```

### 5. Sample Instruction File

Create `/Instructions/RequirementsAnalyst.md` with realistic content (~500+ words):
- Role definition for business analysis specialist
- Task constraints and expectations  
- Output format requirements (structured requirements analysis)
- Example scenarios demonstrating expected analysis depth

## Implementation Constraints

### Code Quality Standards
- **Async-first**: All operations must be fully async with CancellationToken support
- **Error Handling**: Comprehensive try-catch blocks with meaningful exception messages
- **Logging**: Structured logging using existing patterns (`ILogger<T>` with correlation IDs)
- **Validation**: Input validation with clear error messages for invalid requests
- **Resource Management**: Proper disposal of any resources (follow existing HTTP client patterns)

### Integration Patterns
- **Service Lifetime**: Use Scoped lifetime to match existing application services
- **Configuration**: Follow existing `IOptions<T>` patterns if configuration needed
- **Exception Types**: Use existing custom exceptions where appropriate
- **HTTP Responses**: Follow existing controller response patterns for success/error cases

### Testing Requirements
- **Unit Tests**: Create in existing test project structure
- **Test Coverage**: Focus on service orchestration logic and error scenarios
- **Integration Test**: One test demonstrating complete workflow from API to review submission
- **Mock Usage**: Use existing mocking patterns for dependencies

## Critical Implementation Notes

### DO NOT:
- Rewrite any existing working services or interfaces
- Change existing DI registrations or configurations
- Modify existing controller patterns or response formats
- Alter existing health check or logging implementations

### DO:
- Examine existing code patterns first before implementing
- Follow established naming conventions and folder structure
- Use existing error handling and logging patterns
- Integrate with existing correlation ID system
- Test thoroughly with existing test infrastructure

### Architecture Validation Checklist
When complete, verify:
- [ ] Service follows single responsibility principle
- [ ] Dependencies are properly injected via constructor
- [ ] Async operations properly handle cancellation tokens
- [ ] Error handling provides actionable diagnostic information
- [ ] Integration respects existing service boundaries
- [ ] Controller follows existing REST conventions

## Expected Outcome

After implementation, the system should support this workflow:
```bash
POST /api/requirements/analyze
{
    "projectDescription": "Build a task management system for small teams",
    "additionalContext": "React frontend, .NET API backend",
    "constraints": "Must integrate with existing authentication"
}

Response:
{
    "analysisId": "guid",
    "projectDescription": "Build a task management system...",
    "analysisResult": "Detailed requirements analysis from Claude...",
    "reviewId": "guid", 
    "status": "PendingReview",
    "createdAt": "2025-01-15T10:30:00Z"
}
```

This creates the first complete AI orchestration pipeline demonstrating the core system value while integrating seamlessly with existing infrastructure.