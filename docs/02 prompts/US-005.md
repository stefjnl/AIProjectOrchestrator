# Implementation Prompt: US-005 Project Planning Service

## Context & Existing System Analysis

You are implementing **US-005: Project Planning Service** for an AI Project Orchestrator built with Clean Architecture in .NET 9. This creates the second stage of the AI orchestration pipeline, building on the successfully implemented US-004 Requirements Analysis Service.

**CRITICAL**: This is an established, working system with US-004 fully operational. You must examine the existing codebase first, understand the established patterns from US-004, and make only the minimal necessary changes to add the new functionality. Do not rewrite existing working code.

### Existing Foundation (DO NOT MODIFY)
The system already has these working components:
1. **US-004 Complete**: `RequirementsAnalysisService`, `RequirementsController`, all models and workflows operational
2. **IInstructionService** - Loads AI instruction files from `/Instructions/` directory
3. **IAIClient & IAIClientFactory** - Multi-provider AI client system with Claude, LM Studio, OpenRouter
4. **IReviewService** - Human review workflow with in-memory storage
5. **Clean Architecture** - Domain, Application, Infrastructure, API layers with proper DI registration

### Integration Objective
Create `ProjectPlanningService` that consumes approved requirements analysis results and produces structured project plans through AI orchestration. This demonstrates advanced service-to-service integration and context management patterns.

## Implementation Requirements

### 1. Domain Layer Additions

Create these new models in `AIProjectOrchestrator.Domain/Models/`:

```csharp
// ProjectPlanningRequest.cs
public class ProjectPlanningRequest
{
    public Guid RequirementsAnalysisId { get; set; }
    public string? PlanningPreferences { get; set; }
    public string? TechnicalConstraints { get; set; }
    public string? TimelineConstraints { get; set; }
    // Add validation attributes for required RequirementsAnalysisId
}

// ProjectPlanningResponse.cs  
public class ProjectPlanningResponse
{
    public Guid PlanningId { get; set; }
    public Guid RequirementsAnalysisId { get; set; }
    public string ProjectRoadmap { get; set; } = string.Empty;
    public string ArchitecturalDecisions { get; set; } = string.Empty;
    public string Milestones { get; set; } = string.Empty;
    public Guid ReviewId { get; set; }
    public ProjectPlanningStatus Status { get; set; }
    public DateTime CreatedAt { get; set; }
}

// ProjectPlanningStatus.cs
public enum ProjectPlanningStatus
{
    Processing,
    PendingReview, 
    Approved,
    Rejected,
    Failed,
    RequirementsNotApproved
}
```

Create interface in `AIProjectOrchestrator.Domain/Services/`:

```csharp
// IProjectPlanningService.cs
public interface IProjectPlanningService
{
    Task<ProjectPlanningResponse> CreateProjectPlanAsync(
        ProjectPlanningRequest request,
        CancellationToken cancellationToken = default);
        
    Task<ProjectPlanningStatus> GetPlanningStatusAsync(
        Guid planningId,
        CancellationToken cancellationToken = default);
        
    Task<bool> CanCreatePlanAsync(
        Guid requirementsAnalysisId,
        CancellationToken cancellationToken = default);
}
```

### 2. Application Layer Implementation

Create `ProjectPlanningService.cs` in `AIProjectOrchestrator.Application/Services/`:

**Service Orchestration Logic**:
1. **Validate Dependencies**: Check that RequirementsAnalysisId exists and is approved via `IRequirementsAnalysisService.GetAnalysisStatusAsync()`
2. **Retrieve Requirements Context**: Get the approved requirements analysis results from `RequirementsAnalysisService` (you'll need to add a method to retrieve the full analysis)
3. **Load Planning Instructions**: Use `IInstructionService.GetInstructionAsync("ProjectPlanner")`
4. **Context Integration**: Combine planning instructions + requirements analysis results + user preferences into comprehensive AI request
5. **AI Processing**: Call Claude API using `IAIClientFactory`, handle potentially larger responses than US-004
6. **Response Processing**: Parse AI output into structured components (roadmap, architecture, milestones)
7. **Review Submission**: Submit structured plan via `IReviewService.SubmitForReviewAsync()`
8. **Status Management**: Track planning status with in-memory storage (similar to existing patterns)

**Dependencies to Inject**:
- `IRequirementsAnalysisService` (existing - for dependency validation and context retrieval)
- `IInstructionService` (existing)
- `IAIClientFactory` (existing) 
- `IReviewService` (existing)
- `ILogger<ProjectPlanningService>`

**Critical Integration Requirement**:
You need to extend `IRequirementsAnalysisService` to add a method for retrieving the full analysis results:
```csharp
Task<RequirementsAnalysisResponse?> GetAnalysisResultsAsync(
    Guid analysisId, 
    CancellationToken cancellationToken = default);
```

**Context Management Strategy**:
- Monitor combined context size (instructions + requirements + preferences)
- If context becomes too large, implement basic summarization of requirements
- Log context size metrics for performance monitoring
- Preserve essential requirements information while managing prompt length

**Error Handling Requirements**:
- Validate requirements analysis exists and is approved before proceeding
- Handle scenarios where requirements context is too large for AI model
- Graceful handling when planning instructions unavailable
- Comprehensive exception handling with structured logging and correlation IDs

### 3. API Layer Addition

Create `ProjectPlanningController.cs` in `AIProjectOrchestrator.API/Controllers/`:

**Endpoints Required**:
```csharp
[HttpPost("create")]
public async Task<ActionResult<ProjectPlanningResponse>> CreateProjectPlan(
    [FromBody] ProjectPlanningRequest request,
    CancellationToken cancellationToken)

[HttpGet("{planningId:guid}/status")]  
public async Task<ActionResult<ProjectPlanningStatus>> GetPlanningStatus(
    Guid planningId,
    CancellationToken cancellationToken)

[HttpGet("can-create/{requirementsAnalysisId:guid}")]
public async Task<ActionResult<bool>> CanCreatePlan(
    Guid requirementsAnalysisId,
    CancellationToken cancellationToken)
```

Follow the existing controller patterns from `RequirementsController` for:
- Constructor DI injection
- Action method structure and validation
- Error handling and HTTP status codes
- Correlation ID usage and structured logging

### 4. Service Registration

Add to existing DI registration in `Program.cs`:
```csharp
builder.Services.AddScoped<IProjectPlanningService, ProjectPlanningService>();
```

### 5. Enhanced Instruction File

Create `/Instructions/ProjectPlanner.md` with comprehensive content (~800+ words):
- Role definition as technical project planning expert
- Input expectations (approved requirements analysis + preferences)
- Output format requirements with structured sections:
  - Project Roadmap (phases, timelines, dependencies)
  - Architectural Decisions (technology stack, patterns, infrastructure)
  - Milestones (deliverables, success criteria, checkpoints)
- Context handling instructions for variable input sizes
- Example scenarios showing expected planning depth and structure

### 6. Extension to Existing Service

**IMPORTANT**: You must extend the existing `RequirementsAnalysisService` to support context retrieval:

Add to `IRequirementsAnalysisService` interface:
```csharp
Task<RequirementsAnalysisResponse?> GetAnalysisResultsAsync(
    Guid analysisId, 
    CancellationToken cancellationToken = default);
```

Implement in existing `RequirementsAnalysisService` class:
- Retrieve full analysis results from existing in-memory storage
- Include validation that analysis exists and is approved
- Return null if analysis not found or not approved

## Implementation Constraints

### Code Quality Standards
- **Dependency Validation**: Always verify requirements analysis is approved before planning
- **Context Management**: Monitor and log combined context size for AI requests
- **Async Orchestration**: Full async/await with CancellationToken support throughout
- **Error Handling**: Comprehensive exception management with meaningful diagnostic messages
- **Resource Management**: Proper disposal following existing HTTP client patterns
- **State Consistency**: Ensure planning cannot proceed with invalid or unapproved requirements

### Integration Patterns
- **Service Composition**: Follow established patterns from US-004 implementation
- **Multi-Stage Workflow**: Implement proper sequencing and dependency validation
- **Context Preservation**: Maintain traceability from requirements through planning
- **Error Propagation**: Provide actionable diagnostics for multi-stage failures
- **Performance Monitoring**: Track timing and context size metrics

### Advanced Technical Considerations
- **Context Size Limits**: Implement basic monitoring, log warnings when approaching token limits
- **Variable Response Handling**: Parse AI responses into structured components with flexible parsing
- **Dependency State Management**: Handle scenarios where requirements change during planning
- **Memory Management**: Follow existing in-memory storage patterns for status tracking

## Critical Implementation Notes

### DO NOT:
- Rewrite any existing working services, interfaces, or controllers
- Modify existing DI registrations beyond adding the new planning service
- Alter existing error handling, logging, or correlation ID patterns
- Change existing health check or API response formats

### DO:
- Examine existing US-004 implementation patterns first and follow them precisely
- Extend existing interfaces minimally (only add GetAnalysisResultsAsync method)
- Use established naming conventions and folder structure throughout
- Integrate with existing correlation ID and structured logging systems
- Follow existing test project structure and mocking patterns

### Multi-Stage Integration Checklist
When complete, verify:
- [ ] Planning service properly validates requirements analysis approval status
- [ ] Context combination preserves essential requirements information
- [ ] Error handling provides clear diagnostics for dependency failures
- [ ] Service composition follows established Clean Architecture patterns
- [ ] API endpoints maintain consistency with existing controller patterns
- [ ] Status tracking integrates with existing review workflow

### Testing Requirements
- **Unit Tests**: Focus on orchestration logic, dependency validation, context integration
- **Integration Tests**: Multi-stage workflow from requirements → approval → planning → review
- **Error Scenario Tests**: Missing requirements, unapproved dependencies, context size issues
- **Performance Tests**: Monitor context processing time and memory usage

## Expected Workflow Integration

After implementation, the system should support this complete pipeline:

```bash
# Step 1: Create requirements analysis (existing US-004)
POST /api/requirements/analyze
{
    "projectDescription": "Build task management system for small teams"
}
Response: { "analysisId": "guid-1", "reviewId": "guid-2", "status": "PendingReview" }

# Step 2: Approve requirements (existing review workflow)  
POST /api/review/guid-2/approve

# Step 3: Create project plan (new US-005)
POST /api/planning/create  
{
    "requirementsAnalysisId": "guid-1",
    "planningPreferences": "Agile methodology, microservices architecture",
    "technicalConstraints": "Must use .NET and React",
    "timelineConstraints": "6-month delivery timeline"
}

Response: {
    "planningId": "guid-3",
    "requirementsAnalysisId": "guid-1", 
    "projectRoadmap": "Detailed roadmap from Claude...",
    "architecturalDecisions": "Technology and pattern decisions...",
    "milestones": "Key deliverables and timelines...",
    "reviewId": "guid-4",
    "status": "PendingReview"
}
```

This creates a sophisticated two-stage AI orchestration pipeline demonstrating advanced service composition, context management, and multi-stage workflow coordination while maintaining architectural consistency with the existing US-004 foundation.