# Qwen Implementation Prompt: US-003A Simple Output Review API

## Context
You are implementing a human-in-the-loop review system for an AI Project Orchestrator built with .NET 9 Clean Architecture. The existing solution has completed US-001 (Instruction Service) and US-002A (Multi-Provider AI Client) with working Domain, Application, Infrastructure, and API layers, comprehensive logging, health checks, and AI client integration.

## Objective
Create REST API endpoints for submitting AI outputs for human review and approval, enabling human oversight at each pipeline stage of the AI orchestration workflow. This builds directly on the existing AI client system to create controlled workflows where humans approve AI outputs before proceeding to the next stage.

## Implementation Requirements

### 1. Domain Layer Models

**Location**: `src/AIProjectOrchestrator.Domain/Models/Review/ReviewSubmission.cs`
```csharp
public class ReviewSubmission
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string ServiceName { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public string CorrelationId { get; set; } = string.Empty;
    public string PipelineStage { get; set; } = string.Empty;
    public ReviewStatus Status { get; set; } = ReviewStatus.Pending;
    public DateTime SubmittedAt { get; set; } = DateTime.UtcNow;
    public DateTime? ReviewedAt { get; set; }
    public AIRequest? OriginalRequest { get; set; }
    public AIResponse? AIResponse { get; set; }
    public ReviewDecision? Decision { get; set; }
    public Dictionary<string, object> Metadata { get; set; } = new();
}

public class ReviewDecision
{
    public ReviewStatus Status { get; set; }
    public string Reason { get; set; } = string.Empty;
    public string Feedback { get; set; } = string.Empty;
    public DateTime DecidedAt { get; set; } = DateTime.UtcNow;
    public Dictionary<string, string> InstructionImprovements { get; set; } = new();
}

public enum ReviewStatus
{
    Pending = 0,
    Approved = 1,
    Rejected = 2,
    Expired = 3
}
```

**Location**: `src/AIProjectOrchestrator.Domain/Models/Review/SubmitReviewRequest.cs`
```csharp
public class SubmitReviewRequest
{
    public string ServiceName { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public string CorrelationId { get; set; } = string.Empty;
    public string PipelineStage { get; set; } = string.Empty;
    public AIRequest? OriginalRequest { get; set; }
    public AIResponse? AIResponse { get; set; }
    public Dictionary<string, object> Metadata { get; set; } = new();
}

public class ReviewDecisionRequest
{
    public string Reason { get; set; } = string.Empty;
    public string Feedback { get; set; } = string.Empty;
    public Dictionary<string, string> InstructionImprovements { get; set; } = new();
}

public class ReviewResponse
{
    public Guid ReviewId { get; set; }
    public ReviewStatus Status { get; set; }
    public DateTime SubmittedAt { get; set; }
    public string Message { get; set; } = string.Empty;
}
```

### 2. Domain Layer Service Interface

**Location**: `src/AIProjectOrchestrator.Domain/Services/IReviewService.cs`
```csharp
public interface IReviewService
{
    Task<ReviewResponse> SubmitForReviewAsync(SubmitReviewRequest request, CancellationToken cancellationToken = default);
    Task<ReviewSubmission?> GetReviewAsync(Guid reviewId, CancellationToken cancellationToken = default);
    Task<ReviewResponse> ApproveReviewAsync(Guid reviewId, ReviewDecisionRequest? decision = null, CancellationToken cancellationToken = default);
    Task<ReviewResponse> RejectReviewAsync(Guid reviewId, ReviewDecisionRequest decision, CancellationToken cancellationToken = default);
    Task<IEnumerable<ReviewSubmission>> GetPendingReviewsAsync(CancellationToken cancellationToken = default);
    Task<bool> IsHealthyAsync(CancellationToken cancellationToken = default);
}
```

### 3. Domain Layer Configuration

**Location**: `src/AIProjectOrchestrator.Domain/Configuration/ReviewSettings.cs`
```csharp
public class ReviewSettings
{
    public const string SectionName = "ReviewSettings";
    
    public int MaxConcurrentReviews { get; set; } = 100;
    public int ReviewTimeoutHours { get; set; } = 24;
    public int CleanupIntervalMinutes { get; set; } = 60;
    public int MaxContentLength { get; set; } = 50000;
    public List<string> ValidPipelineStages { get; set; } = new() 
    { 
        "Analysis", "Planning", "Stories", "Implementation", "Review" 
    };
}
```

### 4. Application Layer Service Implementation

**Location**: `src/AIProjectOrchestrator.Application/Services/ReviewService.cs`

Implement with these features:
- **In-Memory Storage**: Use `ConcurrentDictionary<Guid, ReviewSubmission>` for thread-safe operations
- **Validation**: Validate request models (required fields, content length limits, valid pipeline stages)
- **Correlation ID Integration**: Propagate correlation IDs from existing AI client system
- **Structured Logging**: Use `ILogger<ReviewService>` with correlation IDs and performance metrics
- **Background Cleanup**: Implement cleanup logic for expired reviews (>24 hours)
- **Thread Safety**: Ensure all operations are thread-safe for concurrent access

Key methods to implement:
- Input validation with meaningful error messages
- Correlation ID propagation and logging
- Status transition validation (Pending â†’ Approved/Rejected only)
- Automatic expiration of old reviews
- Performance metrics logging (review submission rate, approval rate, etc.)

### 5. Application Layer Background Service

**Location**: `src/AIProjectOrchestrator.Application/Services/ReviewCleanupService.cs`
```csharp
public class ReviewCleanupService : BackgroundService
{
    private readonly ILogger<ReviewCleanupService> _logger;
    private readonly IOptions<ReviewSettings> _settings;
    private readonly IServiceProvider _serviceProvider;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Implement periodic cleanup of expired reviews
        // Run every CleanupIntervalMinutes
        // Remove reviews older than ReviewTimeoutHours
        // Log cleanup statistics
    }
}
```

### 6. API Layer Controller

**Location**: `src/AIProjectOrchestrator.API/Controllers/ReviewController.cs`

Follow existing `AITestController` patterns:
```csharp
[ApiController]
[Route("api/[controller]")]
public class ReviewController : ControllerBase
{
    private readonly IReviewService _reviewService;
    private readonly ILogger<ReviewController> _logger;

    [HttpPost("submit")]
    [ProducesResponseType<ReviewResponse>(StatusCodes.Status201Created)]
    [ProducesResponseType<ProblemDetails>(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<ReviewResponse>> SubmitReview([FromBody] SubmitReviewRequest request, CancellationToken cancellationToken) { ... }

    [HttpGet("{id:guid}")]
    [ProducesResponseType<ReviewSubmission>(StatusCodes.Status200OK)]
    [ProducesResponseType<ProblemDetails>(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<ReviewSubmission>> GetReview(Guid id, CancellationToken cancellationToken) { ... }

    [HttpPost("{id:guid}/approve")]
    [ProducesResponseType<ReviewResponse>(StatusCodes.Status200OK)]
    [ProducesResponseType<ProblemDetails>(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<ReviewResponse>> ApproveReview(Guid id, [FromBody] ReviewDecisionRequest? decision, CancellationToken cancellationToken) { ... }

    [HttpPost("{id:guid}/reject")]
    [ProducesResponseType<ReviewResponse>(StatusCodes.Status200OK)]
    [ProducesResponseType<ProblemDetails>(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<ReviewResponse>> RejectReview(Guid id, [FromBody] ReviewDecisionRequest decision, CancellationToken cancellationToken) { ... }

    [HttpGet("pending")]
    [ProducesResponseType<IEnumerable<ReviewSubmission>>(StatusCodes.Status200OK)]
    public async Task<ActionResult<IEnumerable<ReviewSubmission>>> GetPendingReviews(CancellationToken cancellationToken) { ... }
}
```

Use existing patterns for:
- Error handling with `ProblemDetails`
- Correlation ID logging
- Input validation with model state
- Async/await with cancellation tokens
- OpenAPI documentation attributes

### 7. Health Check Integration

**Location**: `src/AIProjectOrchestrator.API/HealthChecks/ReviewHealthCheck.cs`

Follow existing health check patterns from AI client system:
```csharp
public class ReviewHealthCheck : IHealthCheck
{
    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        // Check review service availability
        // Check in-memory storage health
        // Check background cleanup service status
        // Return healthy/unhealthy with metrics
    }
}
```

### 8. Configuration Updates

**Location**: `src/AIProjectOrchestrator.API/appsettings.json`
```json
{
  "ReviewSettings": {
    "MaxConcurrentReviews": 100,
    "ReviewTimeoutHours": 24,
    "CleanupIntervalMinutes": 60,
    "MaxContentLength": 50000,
    "ValidPipelineStages": ["Analysis", "Planning", "Stories", "Implementation", "Review"]
  }
}
```

**Location**: `src/AIProjectOrchestrator.API/appsettings.Development.json`
```json
{
  "ReviewSettings": {
    "ReviewTimeoutHours": 1,
    "CleanupIntervalMinutes": 5,
    "MaxContentLength": 10000
  }
}
```

### 9. Dependency Injection Registration

**Location**: `src/AIProjectOrchestrator.API/Program.cs`

Add registration following existing AI client patterns:
```csharp
// Configure Review settings
builder.Services.Configure<ReviewSettings>(
    builder.Configuration.GetSection(ReviewSettings.SectionName));

// Register Review service as singleton (for in-memory storage consistency)
builder.Services.AddSingleton<IReviewService, ReviewService>();

// Register background cleanup service
builder.Services.AddHostedService<ReviewCleanupService>();

// Add review health check to existing health checks
builder.Services.AddHealthChecks()
    // ... existing health checks
    .AddCheck<ReviewHealthCheck>("review");
```

### 10. Testing Implementation

**Unit Tests** (`tests/AIProjectOrchestrator.UnitTests/Review/`):

Create test files following existing patterns:
- `ReviewSubmissionTests.cs` - Model validation and serialization
- `ReviewServiceTests.cs` - Service operations, validation, error handling
- `ReviewControllerTests.cs` - Controller endpoints, request/response handling
- `ReviewCleanupServiceTests.cs` - Background service cleanup logic

Test scenarios:
- Review submission with valid/invalid data
- Review approval/rejection workflows
- Concurrent access scenarios with thread safety
- Cleanup service expiration logic
- Error handling and logging verification

**Integration Tests** (`tests/AIProjectOrchestrator.IntegrationTests/Review/`):

Create test files:
- `ReviewWorkflowIntegrationTests.cs` - Complete submit â†’ review â†’ approve/reject workflow
- `ReviewHealthCheckIntegrationTests.cs` - Health check functionality
- `ReviewBackgroundServiceIntegrationTests.cs` - Cleanup service integration

Use existing integration test patterns with proper test categorization.

### 11. Model Validation

Add validation attributes to request models:
```csharp
public class SubmitReviewRequest
{
    [Required, MaxLength(100)]
    public string ServiceName { get; set; } = string.Empty;
    
    [Required, MaxLength(50000)]
    public string Content { get; set; } = string.Empty;
    
    [Required]
    public string CorrelationId { get; set; } = string.Empty;
    
    [Required, MaxLength(50)]
    public string PipelineStage { get; set; } = string.Empty;
    
    // ... other properties
}
```

## Technical Implementation Details

### Error Handling Strategy
- Use existing exception handling patterns from AI client system
- Create custom exceptions: `ReviewNotFoundException`, `InvalidReviewStateException`
- Return appropriate HTTP status codes with `ProblemDetails`
- Log all errors with correlation IDs and context

### Logging Requirements
- Follow existing structured logging patterns from AI client system
- Log all review operations: submission, approval, rejection, cleanup
- Include correlation IDs for tracing across services
- Log performance metrics: submission rate, approval rate, queue size
- Use consistent property names with existing logging

### Concurrency Handling
- Use `ConcurrentDictionary<Guid, ReviewSubmission>` for thread-safe storage
- Implement proper locking for review status transitions
- Handle concurrent access to the same review gracefully
- Ensure cleanup service doesn't interfere with active operations

### Integration with Existing Systems
1. **AI Client Integration**: Reviews submitted after `IAIClient.CallAsync()` calls
2. **Correlation ID System**: Use existing correlation ID patterns from `BaseAIClient`
3. **Logging System**: Extend existing Serilog configuration
4. **Health Check System**: Add to existing health check pipeline
5. **Configuration System**: Use existing `IOptions<T>` patterns

## Performance Requirements
- Support 100 concurrent reviews in memory
- Background cleanup without blocking operations
- Efficient lookup operations with Guid keys
- Memory-efficient storage with automatic cleanup
- Response times <100ms for basic operations

## Security Considerations
- Validate all input parameters
- Sanitize content for logging (prevent log injection)
- Implement request size limits
- Use correlation IDs for security auditing
- Follow existing API security patterns

## Definition of Done
- [ ] All models, interfaces, and implementations compile without errors
- [ ] Review service registered in DI container as Singleton
- [ ] Background cleanup service registered and functional
- [ ] Unit tests achieve >80% code coverage and pass
- [ ] Integration tests demonstrate complete workflows
- [ ] Configuration properly loads from appsettings.json
- [ ] Health checks integrated with existing system
- [ ] Controller follows existing API patterns and documentation
- [ ] Correlation ID integration working with existing logging
- [ ] All existing tests continue to pass (US-001, US-002A)
- [ ] Docker containers build and run with new endpoints
- [ ] OpenAPI documentation includes new review endpoints

## Critical Evaluation Points

When reviewing the generated code, examine:
1. **Thread Safety**: Proper use of ConcurrentDictionary and atomic operations
2. **Integration Patterns**: Consistent with existing AI client and instruction service patterns
3. **Error Handling**: Comprehensive exception handling with meaningful messages
4. **Logging Integration**: Proper correlation ID usage and structured logging
5. **API Design**: RESTful endpoints following existing controller conventions
6. **Background Service**: Proper cleanup implementation without blocking
7. **Validation**: Input validation with appropriate error responses
8. **Configuration**: Proper IOptions usage with environment-specific settings

## Implementation Notes
- Build directly on existing patterns from US-002A (AI clients) and US-001 (instruction service)
- Follow existing project structure and naming conventions
- Use existing HTTP client patterns for any external calls
- Ensure all new code follows Clean Architecture dependency rules
- Focus on in-memory storage - avoid database complexity
- Test with realistic review scenarios and concurrent access patterns
- Make the system production-ready with proper monitoring and cleanup