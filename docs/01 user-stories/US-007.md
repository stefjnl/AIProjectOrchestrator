# US-007: Code Generation Service

## User Story
**As a** development team lead  
**I want** to generate working code from approved user stories using optimal AI models  
**So that** developers receive TDD-compliant implementation starting points with automated tests

## Context & Dependencies
This service represents the fourth and final stage of the complete AI orchestration pipeline, transforming approved user stories into working code through intelligent model routing and test-driven development practices.

- **Requires**: Approved Story Generation (US-006) 
- **Produces**: Generated code files with corresponding unit tests
- **Integration**: Four-stage context management with model selection optimization
- **Complexity**: File I/O operations, multi-provider model routing, code quality assessment

## Acceptance Criteria

### Core Functionality
- [ ] **Dependency Validation**: Verify story generation is approved before code generation
- [ ] **Context Aggregation**: Combine requirements + planning + stories as comprehensive development context
- [ ] **Model Selection Logic**: Route to optimal AI provider based on code generation task characteristics
- [ ] **TDD Implementation**: Generate unit tests first, then implementation code
- [ ] **File Output Management**: Create structured code artifacts with proper file organization
- [ ] **Code Quality Validation**: Basic syntax validation and compilation checks

### Model Routing Strategy
- [ ] **Claude Sonnet**: Complex architectural decisions, design patterns, integration logic
- [ ] **Qwen3-coder**: Standard CRUD operations, data access layer, service implementations
- [ ] **DeepSeek**: Alternative coding model for comparison and validation
- [ ] **Routing Logic**: Analyze story complexity and technical requirements for optimal model selection
- [ ] **Fallback Strategy**: Graceful degradation when preferred models unavailable

### API Interface
- [ ] **POST /api/code/generate**: Generate code from approved user stories
- [ ] **GET /api/code/{generationId}/status**: Check code generation progress
- [ ] **GET /api/code/{generationId}/results**: Retrieve generated code artifacts
- [ ] **GET /api/code/{generationId}/files**: List individual generated files
- [ ] **GET /api/code/can-generate/{storyGenerationId}**: Validate generation prerequisites

### Data Models
- [ ] **CodeGenerationRequest**: Input with storyGenerationId, technical preferences, target framework, code style preferences
- [ ] **CodeGenerationResponse**: Output with file artifacts, test files, compilation status, review ID, status
- [ ] **CodeArtifact**: Individual file model with filename, content, file type, compilation status
- [ ] **CodeGenerationStatus**: Workflow states including model selection and compilation phases

### File Management
- [ ] **Structured Output**: Organize generated files by project structure (Controllers/, Services/, Models/, Tests/)
- [ ] **File Naming Conventions**: Follow established .NET conventions for generated artifacts
- [ ] **Content Validation**: Ensure generated files contain valid C# syntax
- [ ] **Test File Generation**: Create corresponding test files for each implementation file

### Quality Assurance
- [ ] **Syntax Validation**: Basic C# compilation checks without full project context
- [ ] **Code Style Compliance**: Follow established project formatting and naming conventions
- [ ] **Test Coverage**: Ensure each implementation file has corresponding test file
- [ ] **Integration Validation**: Generated code should integrate with existing project structure

### Testing Requirements
- [ ] **Unit Tests**: Service methods including model routing logic and file generation
- [ ] **Integration Tests**: API endpoints with file system operations
- [ ] **Model Routing Tests**: Validate selection logic for different story types
- [ ] **File Generation Tests**: Verify proper file creation and organization
- [ ] **Quality Validation Tests**: Syntax checking and compilation verification

## Implementation Guidelines

### Model Selection Logic
```csharp
private async Task<string> SelectOptimalModelAsync(List<UserStory> stories, string technicalContext)
{
    // Analyze story complexity, technical requirements, and available models
    // Route complex architectural stories to Claude
    // Route standard CRUD operations to Qwen3-coder
    // Use DeepSeek for alternative implementations or validation
    // Consider model availability and performance history
}
```

### TDD Code Generation Workflow
1. **Analyze User Stories**: Extract technical requirements and complexity indicators
2. **Select Optimal Model**: Route based on story characteristics and model capabilities  
3. **Generate Tests First**: Create comprehensive unit tests for each story
4. **Generate Implementation**: Create code that satisfies the generated tests
5. **Validate Output**: Perform syntax checking and basic compilation validation
6. **Organize Files**: Structure output according to Clean Architecture patterns

### File Organization Strategy
```
Generated Output Structure:
/Controllers/           # API controllers for user stories
/Services/             # Business logic implementations  
/Models/               # DTOs and request/response models
/Tests/                # Unit tests for all generated components
/README.md             # Implementation guide and setup instructions
```

### Context Management for Code Generation
- **Requirements Context**: Business rules and functional specifications
- **Planning Context**: Architectural decisions and technical constraints
- **Story Context**: Specific implementation requirements and acceptance criteria
- **Project Context**: Existing code patterns and conventions
- **Token Optimization**: Intelligent context summarization for large projects

## Technical Implementation Requirements

### Service Interface
```csharp
public interface ICodeGenerationService
{
    Task<CodeGenerationResponse> GenerateCodeAsync(CodeGenerationRequest request, CancellationToken cancellationToken = default);
    Task<CodeGenerationStatus> GetGenerationStatusAsync(Guid generationId, CancellationToken cancellationToken = default);
    Task<List<CodeArtifact>?> GetGenerationResultsAsync(Guid generationId, CancellationToken cancellationToken = default);
    Task<bool> CanGenerateCodeAsync(Guid storyGenerationId, CancellationToken cancellationToken = default);
    Task<List<CodeArtifact>> GetGeneratedFilesAsync(Guid generationId, CancellationToken cancellationToken = default);
}
```

### Extended Dependencies
Add minimal methods to existing services:
```csharp
// Add to IStoryGenerationService
Task<List<UserStory>?> GetApprovedStoriesAsync(Guid storyGenerationId, CancellationToken cancellationToken = default);

// Add to IProjectPlanningService  
Task<string?> GetTechnicalContextAsync(Guid planningId, CancellationToken cancellationToken = default);
```

### File System Integration
- **Output Directory Management**: Create structured directories for generated code
- **File Conflict Resolution**: Handle naming conflicts and duplicate files
- **Cleanup Strategy**: Remove generated files after specified retention period
- **Compression**: Zip generated files for easy download and distribution

### Code Quality Validation
```csharp
private async Task<bool> ValidateGeneratedCodeAsync(List<CodeArtifact> artifacts)
{
    // Perform basic C# syntax validation
    // Check for common compilation errors
    // Validate naming conventions and code style
    // Ensure test files exist for implementation files
    // Return compilation and quality status
}
```

## Definition of Done
- [ ] All tests written first using TDD approach (minimum 15 tests)
- [ ] `ICodeGenerationService` interface defined with comprehensive methods
- [ ] `CodeGenerationService` implementation following established orchestration pattern
- [ ] `CodeController` with all required endpoints
- [ ] Domain models for code generation workflow
- [ ] Model selection and routing logic implementation
- [ ] File system integration with structured output management  
- [ ] Extended upstream services with minimal required methods
- [ ] `CodeGenerator.md` instruction files for each AI model (Claude, Qwen3-coder, DeepSeek)
- [ ] Code quality validation and syntax checking
- [ ] All unit tests passing (minimum 15 tests covering model routing and file operations)
- [ ] All integration tests passing (minimum 8 API and file system tests)
- [ ] Service registered in DI container with proper dependencies
- [ ] Solution builds without errors and all existing tests continue passing

## Out of Scope (Future Stories)
- Full project compilation and build integration
- Advanced code refactoring and optimization
- Integration with external IDEs or development environments
- Code deployment and CI/CD pipeline integration
- Advanced code metrics and quality analysis
- Real-time collaborative editing or version control integration

## Technical Challenges & Learning Opportunities

### Model Routing Intelligence
This service provides direct practice with AI model selection strategies - a critical skill for senior developers working with AI tools. The routing logic requires analysis of story complexity, technical requirements, and model capabilities.

### File System Operations
Enterprise-grade file management patterns including structured output, cleanup strategies, and conflict resolution. This demonstrates full-stack thinking beyond just API development.

### Code Quality Assessment  
Direct practice evaluating AI-generated code quality, syntax validation, and architectural compliance - exactly the systematic code evaluation skills needed for senior developer interviews.

### Multi-Stage Context Management
Managing context from four different sources (requirements, planning, stories, project context) while optimizing for token limits and maintaining coherent technical specifications.

This represents the capstone service that completes the full automation pipeline from high-level ideas to working code, providing maximum learning value for code evaluation skills while demonstrating sophisticated enterprise integration patterns.