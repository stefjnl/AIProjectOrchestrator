<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stories & Prompts Management - AI Orchestrator</title>
    <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
    <div class="container">
        <!-- Header Section -->
        <div class="header">
            <div class="main-nav-buttons">
                <a href="/projects/create.html"><button>Create New Project</button></a>
                <a href="/projects/list.html"><button>View All Projects</button></a>
                <a href="/reviews/queue.html"><button>Go To Review Queue</button></a>
            </div>
            <h1 id="projectTitle">Stories Management</h1>
            <p id="projectDescription">Stories management workspace for prompt generation.</p>
        </div>

        <!-- Stories Management Interface -->
        <div id="summaryStats" class="stories-summary"></div>
        <div id="storiesContainer" class="stories-grid"></div>
        <button id="backToWorkflow" class="primary-btn">‚Üê Back to Project Workflow</button>
    </div>

    <script src="/js/api.js"></script>
    <script src="/js/workflow.js"></script>
    <script>
        let workflowManager;

        window.addEventListener('DOMContentLoaded', async function() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('projectId');
            
            if (!projectId) {
                alert('Project ID is required');
                window.location.href = '/projects/list.html';
                return;
            }

            workflowManager = new WorkflowManager(projectId);

            // Show loading state
            document.body.classList.add('loading');
            
            try {
                // Load state from API instead of localStorage
                await workflowManager.loadStateFromAPI();
                
                // Load project info
                const project = await window.APIClient.getProject(projectId);
                workflowManager.recordApiSuccess();
                document.getElementById('projectTitle').textContent = project.name;
                document.getElementById('projectDescription').textContent = project.description;

                // Load and render stories
                await loadAndRenderStories();

                // Start polling for updates
                workflowManager.startPolling();
                
                // Hide loading state
                document.body.classList.remove('loading');
                
            } catch (error) {
                console.error('Failed to initialize stories overview:', error);
                showError('Failed to load stories. Please try again.');
                document.body.classList.remove('loading');
            }

            // Set up back button - redirect to workflow page
            document.getElementById('backToWorkflow').addEventListener('click', function() {
                window.location.href = `/projects/workflow.html?projectId=${encodeURIComponent(workflowManager.projectId)}`;
            });

            // Trigger sync with workflow page
            if (typeof workflowManager.syncWithStoriesPage === 'function') {
                await workflowManager.syncWithStoriesPage();
            }

            // Page visibility refresh
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden && workflowManager.state.enableStoriesMVP) {
                    workflowManager.refreshState().then(loadAndRenderStories).catch(console.error);
                }
            });
            
            // Cleanup on page unload
            window.addEventListener('beforeunload', function() {
                workflowManager.stopPolling();
            });
        });

        async function loadAndRenderStories() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('projectId');
            
            if (!workflowManager.state.storiesApproved || !workflowManager.state.storyGenerationId) {
                showError('No stories available. Please complete the story generation stage first.', projectId);
                return;
            }

            try {
                // Fetch stories from API
                const stories = await window.APIClient.getStories(workflowManager.state.storyGenerationId);
                workflowManager.recordApiSuccess();
                
                if (!stories || stories.length === 0) {
                    showError('No stories found for this project.', projectId);
                    return;
                }
                
                // Get prompt statuses for each story
                const storyPrompts = workflowManager.state.storyPrompts || [];
                
                renderStoriesGrid(stories, storyPrompts);
                updateSummaryStats(stories, storyPrompts);
                
            } catch (error) {
                console.error('Error loading stories:', error);
                workflowManager.recordApiFailure();
                
                if (workflowManager.isApiDisabled()) {
                    showMaintenanceBanner();
                }
                
                if (error.message.includes('404')) {
                    showError('Stories data not found. The stories may not be approved yet.', projectId);
                } else {
                    showError('Failed to load stories from the server.', projectId);
                }
            }
        }

        function renderStoriesGrid(stories, storyPrompts) {
            const container = document.getElementById('storiesContainer');
            
            container.innerHTML = stories.map((story, index) => {
                // Find the story prompt for this story
                const storyPrompt = storyPrompts.find(sp => sp.storyIndex === index);
                const status = storyPrompt?.status || 'Draft';
                
                const statusClass = getStatusClass(status);
                
                // Extract story details
                const title = story.Title || story.title || `Story ${index + 1}`;
                const description = story.Description || story.description || '';
                const acceptanceCriteria = story.AcceptanceCriteria || story.acceptanceCriteria || [];
                
                // Create preview text (first 100 chars of description)
                const previewText = description.length > 100 ? description.substring(0, 100) + '...' : description;
                
                // Format acceptance criteria for display
                const criteriaHtml = acceptanceCriteria.map(criteria => `<li>${criteria}</li>`).join('');
                
                // Determine if the story is approved
                const isApproved = status === 'Approved';
                
                return `
                    <div class="story-card" data-story-index="${index}" data-story-id="${story.Id || index}">
                        <div class="story-header">
                            <h3>${title}</h3>
                            <span class="status-badge ${statusClass}">${status}</span>
                        </div>
                        
                        <div class="story-content expandable">
                            <div class="preview">
                                <p>${previewText}</p>
                                ${description.length > 100 ? '<button class="read-more-btn" data-toggle="expand">Read More</button>' : ''}
                            </div>
                            <div class="full-content hidden">
                                <div class="story-description">${description.replace(/\n/g, '<br>')}</div>
                                ${criteriaHtml ? `<div class="acceptance-criteria"><h4>Acceptance Criteria:</h4><ul>${criteriaHtml}</ul></div>` : ''}
                            </div>
                        </div>
                        
                        <div class="story-edit-mode">
                            <input type="text" class="story-title-edit" value="${title}" placeholder="Story Title">
                            <textarea class="story-description-edit" placeholder="Story description...">${description}</textarea>
                            <textarea class="story-acceptance-criteria-edit" placeholder="Acceptance criteria...">${acceptanceCriteria.join('\n')}</textarea>
                            <div class="edit-actions">
                                <button class="save-btn">Save Changes</button>
                                <button class="cancel-btn">Cancel</button>
                            </div>
                        </div>
                        
                        <div class="story-actions">
                            <button class="edit-btn">Edit</button>
                            <button class="approve-btn ${isApproved ? 'hidden' : ''}">Approve</button>
                            <button class="reject-btn ${status === 'Rejected' ? 'hidden' : ''}">Reject</button>
                            <button class="generate-prompt-btn" ${isApproved ? '' : 'disabled'}>Generate Prompt</button>
                        </div>
                    </div>
                `;
            }).join('');

            // Attach event listeners for the new UI elements
            attachStoryEventListeners();
            
            updateSummaryStats(stories, storyPrompts);
        }
        
        function getStatusClass(status) {
            if (!status || typeof status !== 'string') {
                console.warn('Invalid status value in getStatusClass:', status, 'type:', typeof status);
                return 'draft';
            }
            
            const lowerStatus = status.toLowerCase();
            switch(lowerStatus) {
                case 'approved': return 'approved';
                case 'pending': 
                case 'pending review': return 'pending';
                case 'not started': 
                case 'notstarted': return 'draft';
                case 'rejected': return 'rejected';
                case 'draft': return 'draft';
                default: 
                    console.warn('Unknown status value:', lowerStatus);
                    return 'draft';
            }
        }

        function updateSummaryStats(stories, storyPrompts) {
            const summaryEl = document.getElementById('summaryStats');
            if (!summaryEl) return;

            // Calculate statistics
            const totalStories = stories.length;
            const approvedStories = stories.filter(story => {
                const storyPrompt = storyPrompts.find(sp => sp.storyIndex === stories.indexOf(story));
                return storyPrompt?.status === 'Approved';
            }).length;
            const draftStories = stories.filter(story => {
                const storyPrompt = storyPrompts.find(sp => sp.storyIndex === stories.indexOf(story));
                return !storyPrompt || storyPrompt.status === 'Draft';
            }).length;
            const rejectedStories = stories.filter(story => {
                const storyPrompt = storyPrompts.find(sp => sp.storyIndex === stories.indexOf(story));
                return storyPrompt?.status === 'Rejected';
            }).length;

            summaryEl.innerHTML = `
                <div class="progress-indicator">
                    <div class="progress-item">
                        <span class="progress-number">${totalStories}</span>
                        <span class="progress-label">Total Stories</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-number">${approvedStories}</span>
                        <span class="progress-label">Approved</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-number">${draftStories}</span>
                        <span class="progress-label">Draft</span>
                    </div>
                    <div class="progress-item">
                        <span class="progress-number">${rejectedStories}</span>
                        <span class="progress-label">Rejected</span>
                    </div>
                </div>
                <div style="margin-top: 15px; font-size: 0.9em; color: #6c757d;">
                    Progress: ${approvedStories} of ${totalStories} stories approved (${totalStories > 0 ? Math.round((approvedStories/totalStories)*100) : 0}%)
                </div>
            `;
        }

        function attachStoryEventListeners() {
            const container = document.getElementById('storiesContainer');
            
            // Handle read more/less buttons
            container.addEventListener('click', function(e) {
                if (e.target.classList.contains('read-more-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const fullContent = storyCard.querySelector('.full-content');
                    const preview = storyCard.querySelector('.preview');
                    
                    fullContent.classList.remove('hidden');
                    fullContent.classList.add('show');
                    preview.style.display = 'none';
                    e.target.textContent = 'Read Less';
                    e.target.classList.remove('read-more-btn');
                    e.target.classList.add('read-less-btn');
                } else if (e.target.classList.contains('read-less-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const fullContent = storyCard.querySelector('.full-content');
                    const preview = storyCard.querySelector('.preview');
                    
                    fullContent.classList.remove('show');
                    fullContent.classList.add('hidden');
                    preview.style.display = 'block';
                    e.target.textContent = 'Read More';
                    e.target.classList.remove('read-less-btn');
                    e.target.classList.add('read-more-btn');
                }
                
                // Handle edit button
                if (e.target.classList.contains('edit-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const editMode = storyCard.querySelector('.story-edit-mode');
                    const storyContent = storyCard.querySelector('.story-content');
                    const storyActions = storyCard.querySelector('.story-actions');
                    
                    // Toggle edit mode
                    if (editMode.classList.contains('active')) {
                        editMode.classList.remove('active');
                        storyContent.style.display = 'block';
                        storyActions.style.display = 'flex';
                        e.target.textContent = 'Edit';
                    } else {
                        editMode.classList.add('active');
                        storyContent.style.display = 'none';
                        storyActions.style.display = 'none';
                        e.target.textContent = 'Cancel';
                    }
                }
                
                // Handle approve button
                if (e.target.classList.contains('approve-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const storyIndex = storyCard.dataset.storyIndex;
                    const statusBadge = storyCard.querySelector('.status-badge');
                    
                    // Show loading state
                    e.target.innerHTML = '<span class="loading"></span>Approving...';
                    e.target.disabled = true;
                    
                    // Call API to approve story
                    approveStory(storyIndex, storyCard);
                }
                
                // Handle reject button
                if (e.target.classList.contains('reject-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const storyIndex = storyCard.dataset.storyIndex;
                    const statusBadge = storyCard.querySelector('.status-badge');
                    
                    // Show loading state
                    e.target.innerHTML = '<span class="loading"></span>Rejecting...';
                    e.target.disabled = true;
                    
                    // Call API to reject story
                    rejectStory(storyIndex, storyCard);
                }
                
                // Handle save changes button
                if (e.target.classList.contains('save-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const storyIndex = storyCard.dataset.storyIndex;
                    
                    // Show loading
                    e.target.innerHTML = '<span class="loading"></span>Saving...';
                    e.target.disabled = true;
                    
                    // Call API to update story
                    updateStory(storyIndex, storyCard);
                }
                
                // Handle cancel button
                if (e.target.classList.contains('cancel-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const editMode = storyCard.querySelector('.story-edit-mode');
                    const storyContent = storyCard.querySelector('.story-content');
                    const storyActions = storyCard.querySelector('.story-actions');
                    const editBtn = storyCard.querySelector('.edit-btn');
                    
                    editMode.classList.remove('active');
                    storyContent.style.display = 'block';
                    storyActions.style.display = 'flex';
                    editBtn.textContent = 'Edit';
                }
                
                // Handle generate prompt button
                if (e.target.classList.contains('generate-prompt-btn')) {
                    const storyCard = e.target.closest('.story-card');
                    const storyIndex = storyCard.dataset.storyIndex;
                    
                    generatePrompt(storyIndex);
                }
            });
        }

        async function approveStory(storyIndex, storyCard) {
            try {
                // In a real implementation, we would call the API to approve the individual story
                // For now, we'll simulate the approval and update the UI
                
                // Update UI immediately for better UX
                const statusBadge = storyCard.querySelector('.status-badge');
                statusBadge.textContent = 'Approved';
                statusBadge.className = 'status-badge approved';
                
                const approveBtn = storyCard.querySelector('.approve-btn');
                approveBtn.classList.add('hidden');
                
                const rejectBtn = storyCard.querySelector('.reject-btn');
                rejectBtn.classList.remove('hidden');
                
                const generateBtn = storyCard.querySelector('.generate-prompt-btn');
                generateBtn.disabled = false;
                
                // Reset button text
                approveBtn.innerHTML = 'Approve';
                approveBtn.disabled = false;
                
                // Refresh stats
                await workflowManager.loadStateFromAPI();
                await loadAndRenderStories();
                
                // Show success message
                showNotification('Story approved successfully!', 'success');
                
            } catch (error) {
                console.error('Failed to approve story:', error);
                
                // Reset button text
                const approveBtn = storyCard.querySelector('.approve-btn');
                approveBtn.innerHTML = 'Approve';
                approveBtn.disabled = false;
                
                // Show error message
                showNotification('Failed to approve story. Please try again.', 'error');
            }
        }

        async function rejectStory(storyIndex, storyCard) {
            try {
                // In a real implementation, we would call the API to reject the individual story
                // For now, we'll simulate the rejection and update the UI
                
                // Update UI immediately for better UX
                const statusBadge = storyCard.querySelector('.status-badge');
                statusBadge.textContent = 'Rejected';
                statusBadge.className = 'status-badge rejected';
                
                const rejectBtn = storyCard.querySelector('.reject-btn');
                rejectBtn.classList.add('hidden');
                
                const approveBtn = storyCard.querySelector('.approve-btn');
                approveBtn.classList.remove('hidden');
                
                const generateBtn = storyCard.querySelector('.generate-prompt-btn');
                generateBtn.disabled = true;
                
                // Reset button text
                rejectBtn.innerHTML = 'Reject';
                rejectBtn.disabled = false;
                
                // Refresh stats
                await workflowManager.loadStateFromAPI();
                await loadAndRenderStories();
                
                // Show success message
                showNotification('Story rejected successfully!', 'success');
                
            } catch (error) {
                console.error('Failed to reject story:', error);
                
                // Reset button text
                const rejectBtn = storyCard.querySelector('.reject-btn');
                rejectBtn.innerHTML = 'Reject';
                rejectBtn.disabled = false;
                
                // Show error message
                showNotification('Failed to reject story. Please try again.', 'error');
            }
        }

        async function updateStory(storyIndex, storyCard) {
            try {
                const titleInput = storyCard.querySelector('.story-title-edit');
                const descriptionInput = storyCard.querySelector('.story-description-edit');
                const criteriaInput = storyCard.querySelector('.story-acceptance-criteria-edit');
                const editMode = storyCard.querySelector('.story-edit-mode');
                const storyContent = storyCard.querySelector('.story-content');
                const storyActions = storyCard.querySelector('.story-actions');
                const editBtn = storyCard.querySelector('.edit-btn');
                
                // Prepare updated story data
                const updatedStory = {
                    Title: titleInput.value,
                    Description: descriptionInput.value,
                    AcceptanceCriteria: criteriaInput.value.split('\n').filter(c => c.trim())
                };
                
                // In a real implementation, we would call the API to update the story
                // For now, we'll simulate the update and update the UI
                
                // Update story header with new title
                const storyHeader = storyCard.querySelector('.story-header h3');
                storyHeader.textContent = updatedStory.Title;
                
                // Update preview text
                const preview = storyCard.querySelector('.preview p');
                const newPreview = updatedStory.Description.length > 100 ?
                    updatedStory.Description.substring(0, 100) + '...' : updatedStory.Description;
                preview.textContent = newPreview;
                
                // Hide edit mode
                editMode.classList.remove('active');
                storyContent.style.display = 'block';
                storyActions.style.display = 'flex';
                editBtn.textContent = 'Edit';
                
                // Reset button text
                const saveBtn = storyCard.querySelector('.save-btn');
                saveBtn.innerHTML = 'Save Changes';
                saveBtn.disabled = false;
                
                // Refresh stats
                await workflowManager.loadStateFromAPI();
                await loadAndRenderStories();
                
                // Show success notification
                showNotification('Story updated successfully!', 'success');
                
            } catch (error) {
                console.error('Failed to update story:', error);
                
                // Reset button text
                const saveBtn = storyCard.querySelector('.save-btn');
                saveBtn.innerHTML = 'Save Changes';
                saveBtn.disabled = false;
                
                // Show error toast
                showNotification('Failed to update story. Please try again.', 'error');
            }
        }

        async function generatePrompt(storyIndex) {
            if (!workflowManager.state.storiesApproved) {
                alert('Stories must be approved before generating prompts.');
                return;
            }

            try {
                console.log('Generating prompt for story index:', storyIndex);
                
                const request = {
                    storyGenerationId: workflowManager.state.storyGenerationId,
                    storyIndex: storyIndex,
                    technicalPreferences: {}
                };
                
                const response = await window.APIClient.generatePrompt(request);
                workflowManager.recordApiSuccess();
                
                // Don't save state - will be updated by polling
                alert('Prompt generation submitted for review. Please check the review queue.');
                
                // Stories-specific refresh: load state without UI update
                await workflowManager.loadStateFromAPI();
                // Debug log after refresh
                console.log('State refreshed after prompt generation:', workflowManager.state);
                await loadAndRenderStories();
                
            } catch (error) {
                console.error('Error generating prompt:', error);
                workflowManager.recordApiFailure();
                if (workflowManager.isApiDisabled()) {
                    showMaintenanceBanner();
                }
                alert('Error generating prompt: ' + error.message);
            }
        }
        
        async function viewPrompt(promptId) {
            try {
                const prompt = await window.APIClient.getPrompt(promptId);
                workflowManager.recordApiSuccess();
                
                // Simple inline view for MVP
                const viewDiv = document.createElement('div');
                viewDiv.id = 'tempPromptView';
                viewDiv.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center;';
                
                viewDiv.innerHTML = `
                    <div style="background: white; padding: 20px; max-width: 80%; max-height: 80%; overflow: auto; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                            <h3>Generated Prompt</h3>
                            <button onclick="closeTempView()" style="background: #dc3545; color: white; border: none; padding: 5px 10px; cursor: pointer;">Close</button>
                        </div>
                        <pre style="white-space: pre-wrap; background: #f8f9fa; padding: 15px; border-radius: 4px; max-height: 400px; overflow: auto;">${escapeHTML(prompt.generatedPrompt)}</pre>
                        <div style="margin-top: 15px; text-align: right;">
                            <button onclick="copyPrompt('${promptId}')" style="margin-right: 10px; padding: 5px 10px;">Copy</button>
                            <button onclick="downloadSinglePrompt('${promptId}')" style="padding: 5px 10px;">Download .md</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(viewDiv);
                
            } catch (error) {
                workflowManager.recordApiFailure();
                alert(`Failed to load prompt: ${error.message}`);
            }
        }
        
        function closeTempView() {
            const view = document.getElementById('tempPromptView');
            if (view) view.remove();
        }

        function copyPrompt(promptId) {
            // For MVP, copy from the displayed content
            const pre = document.querySelector('#tempPromptView pre');
            if (pre) {
                navigator.clipboard.writeText(pre.textContent).then(() => {
                    alert('Prompt copied to clipboard!');
                }).catch(() => {
                    alert('Failed to copy - please select and copy manually.');
                });
            }
        }

        async function downloadSinglePrompt(promptId) {
            try {
                const prompt = await window.APIClient.getPrompt(promptId);
                workflowManager.recordApiSuccess();
                
                const blob = new Blob([prompt.generatedPrompt], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `prompt-${promptId}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                closeTempView();
            } catch (error) {
                workflowManager.recordApiFailure();
                alert(`Download failed: ${error.message}`);
            }
        }

        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification-toast ${type}`;
            notification.textContent = message;
            
            // Add to document
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        function showError(message, projectId) {
            const container = document.getElementById('storiesContainer');
            container.innerHTML = `
                <div class="error-container" style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 8px; margin: 20px;">
                    <h3>Error Loading Stories</h3>
                    <p>${message}</p>
                    <button onclick="loadAndRenderStories()" class="primary-btn" style="margin-right: 10px;">Retry</button>
                    <button onclick="goBackToWorkflow(${projectId})" class="btn btn-primary">Back to Workflow</button>
                </div>
            `;
        }

        function showBackToWorkflow(projectId) {
            const storiesGrid = document.getElementById('storiesContainer');
            storiesGrid.innerHTML = `
                <div class="error-container">
                    <button onclick="goBackToWorkflow(${projectId})" class="btn btn-primary">
                        Back to Workflow
                    </button>
                </div>
            `;
        }

        function goBackToWorkflow(projectId) {
            if (projectId) {
                window.location.href = `workflow.html?projectId=${projectId}`;
            } else {
                window.location.href = 'workflow.html';
            }
        }

        // Maintenance banner for circuit breaker
        function showMaintenanceBanner() {
            if (document.getElementById('maintenance-banner')) return;
            const banner = document.createElement('div');
            banner.id = 'maintenance-banner';
            banner.className = 'maintenance-banner';
            banner.innerHTML = `
                <div style="background: #ff6b6b; color: white; padding: 10px; text-align: center; margin: 10px;">
                    <strong>API Maintenance Mode</strong><br>
                    System temporarily unavailable. Retrying in 60s or <button onclick="location.reload()" style="background: white; color: #ff6b6b; border: none; padding: 2px 8px; cursor: pointer;">Refresh</button>
                </div>
            `;
            document.body.insertBefore(banner, document.body.firstChild);
        }
    </script>
</body>
</html>