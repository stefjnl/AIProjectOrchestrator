Top-Level Overview

  The AI Project Orchestrator is a .NET 9 Web API application that automates the entire software development pipeline through AI orchestration. It transforms high-level project ideas into structured requirements, project plans, user stories, and ultimately working code implementations.

  The system is built on Clean Architecture principles with distinct layers for domain logic, application services, and infrastructure concerns. It integrates with multiple AI providers (Claude, LM Studio, OpenRouter) and implements a complete human-in-the-loop review process for quality control.

  From a user standpoint, the AI Project Orchestrator provides a workflow that guides users through transforming ideas into actionable development artifacts:

   1. Requirements Analysis (US-004): Users submit high-level project ideas and receive structured requirements analysis generated by AI, which then goes through human review and approval.

   2. Project Planning (US-005): Once requirements are approved, users can generate comprehensive project plans with roadmaps and architecture decisions, also requiring human approval.

   3. Story Generation (US-006): Approved project plans are used to generate implementable user stories with acceptance criteria, ready for development teams.

   4. Code Generation (US-007B): Approved user stories can be transformed into working code implementations with associated unit tests through intelligent model routing.

   5. Human Review Process (US-003A): Throughout each stage, AI-generated outputs are submitted for human review, ensuring quality control and maintaining human oversight in the automated pipeline.

   6. Review Interface (US-008): A web interface allows stakeholders to easily review and approve AI-generated outputs, with dashboard views of workflow status.

     From a developer's perspective, the system provides several key architectural components and integration points:

   1. Service Configuration System (US-001):
      - Loads AI instruction files dynamically from the /Instructions/ directory
      - Maps service names to instruction files using naming conventions
      - Provides structured instruction content to requesting services
      - Supports configurable instruction directory paths

   2. Multi-Provider AI Client Interface (US-002A):
      - Unified IAIClient interface for interacting with different AI providers
      - Concrete implementations for Claude, LM Studio, and OpenRouter
      - Enterprise-grade resilience features including retry logic and error handling
      - Configuration-driven provider settings with API keys and timeouts

   3. Human Review API (US-003A):
      - REST endpoints for submitting AI outputs for human review
      - In-memory storage with thread-safe operations
      - Integration with existing correlation ID and logging systems
      - Approval/rejection workflows with feedback collection

   4. Core Orchestration Services:
      - Requirements Analysis Service integrating instruction loading, AI calls, and review submission
      - Project Planning Service consuming approved requirements and producing project plans
      - Story Generation Service creating implementable user stories from approved plans
      - Code Generation Service (in progress) that will produce working code from user stories

   5. Clean Architecture Implementation:
      - Proper separation of concerns with Domain, Application, Infrastructure, and API layers
      - Dependency injection with appropriate service lifetimes
      - Async-first design with cancellation token support
      - Structured logging and error handling throughout


Service Architecture and Workflows

  The system follows a four-stage pipeline architecture with each service building upon the previous ones:

  Core Architecture Layers:
   1. Domain Layer: Contains interfaces, models, and business logic without external dependencies
   2. Application Layer: Implements orchestration services that coordinate between domain interfaces and infrastructure
   3. Infrastructure Layer: Houses external integrations like AI clients, file I/O, and configuration
   4. API Layer: Provides RESTful endpoints and handles HTTP concerns

  Workflow Pipeline:
   1. Stage 1 - Requirements Analysis Service:
      - Takes project descriptions as input
      - Loads RequirementsAnalyst.md instructions
      - Calls Claude API via IAIClient
      - Submits output to IReviewService for human approval

   2. Stage 2 - Project Planning Service:
      - Requires approved requirements analysis
      - Loads ProjectPlanner.md instructions
      - Combines requirements + planning instructions
      - Generates project plans with roadmaps and architecture decisions
      - Submits output for human review

   3. Stage 3 - Story Generation Service:
      - Requires both approved requirements and project plans
      - Loads StoryGenerator.md instructions
      - Aggregates context from all previous stages
      - Generates implementable user stories with acceptance criteria
      - Implements token optimization for large context windows

   4. Stage 4 - Code Generation Service:
      - Requires approved user stories
      - Uses intelligent model routing (Claude for architecture, Qwen3-coder for CRUD, DeepSeek for validation)
      - Implements TDD workflow (tests first, then implementation)
      - Manages file I/O operations for code artifacts
      - Performs basic code quality validation

  Key Integration Patterns:
   - All services use dependency injection for loose coupling
   - Centralized instruction loading via IInstructionService
   - Unified AI client access through IAIClient abstraction
   - Consistent human review workflow via IReviewService
   - Structured logging with correlation IDs throughout
   - Comprehensive error handling and graceful degradation

  Each service follows the same orchestration pattern: validate input → load instructions → retrieve context → call AI → process response → submit for review.


  Application Overview:

  The AI Project Orchestrator is a .NET 9 Web API that automates the software development pipeline through AI orchestration, transforming high-level project ideas into working code with human oversight.

  User Functionality

  From a user perspective, the application provides a complete workflow:
   1. Submit project ideas for AI-powered requirements analysis
   2. Generate project plans with roadmaps and architecture decisions
   3. Create implementable user stories with acceptance criteria
   4. (In progress) Generate working code implementations with unit tests
   5. Review and approve all AI-generated outputs through a human review process

  Developer Functionality

  From a technical standpoint, the system offers:
   1. Dynamic AI instruction loading system
   2. Multi-provider AI client abstraction (Claude, LM Studio, OpenRouter)
   3. Human review API with in-memory storage
   4. Clean Architecture implementation with proper separation of concerns
   5. Comprehensive error handling and structured logging

  Architecture & Workflow

  The system implements a four-stage pipeline:
   1. Requirements Analysis Service
   2. Project Planning Service
   3. Story Generation Service
   4. Code Generation Service (in progress)

  Each stage builds upon the previous ones, following consistent orchestration patterns that include input validation, instruction loading, AI processing, and human review submission. The architecture emphasizes loose coupling through dependency injection, async-first design, and centralized cross-cutting concerns like logging and error handling.